{"task_id": 146, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from math import ceil\n\nfrom youtube_dl.aes import xor, aes_decrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    if len(iv) != BLOCK_SIZE_BYTES:\n        raise ValueError(\"IV must be 16 bytes long\")\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        start = i * BLOCK_SIZE_BYTES\n        end = start + BLOCK_SIZE_BYTES\n        block = data[start:end]\n        # Pad block with zeros if incomplete block (should not normally happen if ciphertext is padded)\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR decrypted plaintext block with previous ciphertext block (or IV for first block)\n        plain_block = xor(decrypted_block, previous_block)\n\n        decrypted_data += plain_block\n\n        previous_block = block  # current ciphertext block becomes next iteration's 'previous_block'\n\n    # Trim to original data length (in case last block was padded)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data", "from youtube_dl.aes import xor, aes_decrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = (len(data) + BLOCK_SIZE_BYTES - 1) // BLOCK_SIZE_BYTES\n\n    decrypted_data = []\n    prev_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # pad block with zeros if not full block (usually ciphertext length is multiple of block size,\n        # but just to be safe and consistent with the aes_ctr_decrypt approach)\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR with previous ciphertext block or iv to get plaintext block\n        plaintext_block = xor(decrypted_block, prev_block)\n        decrypted_data += plaintext_block\n\n        prev_block = block\n\n    # truncate to original data length in case of padding in last block\n    return decrypted_data[:len(data)]", "from youtube_dl.aes import xor, aes_decrypt, key_expansion\nfrom math import ceil\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    prev_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # If block is shorter than BLOCK_SIZE_BYTES, pad with zeros (should be rare in CBC decryption)\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        # Decrypt the current block\n        decrypted_block = aes_decrypt(block, expanded_key)\n\n        # XOR with previous ciphertext block (or IV for first block)\n        plain_block = xor(decrypted_block, prev_block)\n\n        decrypted_data += plain_block\n\n        # Update prev_block to current ciphertext block\n        prev_block = block\n\n    # Truncate plaintext to original data length\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data", "from youtube_dl.aes import xor, aes_decrypt, key_expansion\nfrom math import ceil\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Pad incomplete block with zeros if necessary\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        plaintext_block = xor(decrypted_block, previous_block)\n\n        decrypted_data += plaintext_block\n        previous_block = block\n\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data", "from math import ceil\nfrom youtube_dl.aes import xor, aes_decrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Pad incomplete blocks with zeros (if any)\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        plain_block = xor(decrypted_block, previous_block)\n        decrypted_data += plain_block\n        previous_block = block\n\n    # Trim to original data length\n    return decrypted_data[:len(data)]"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\n\nfrom youtube_dl.aes import xor, aes_decrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    if len(iv) != BLOCK_SIZE_BYTES:\n        raise ValueError(\"IV must be 16 bytes long\")\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        start = i * BLOCK_SIZE_BYTES\n        end = start + BLOCK_SIZE_BYTES\n        block = data[start:end]\n        # Pad block with zeros if incomplete block (should not normally happen if ciphertext is padded)\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR decrypted plaintext block with previous ciphertext block (or IV for first block)\n        plain_block = xor(decrypted_block, previous_block)\n\n        decrypted_data += plain_block\n\n        previous_block = block  # current ciphertext block becomes next iteration's 'previous_block'\n\n    # Trim to original data length (in case last block was padded)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom youtube_dl.aes import xor, aes_decrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = (len(data) + BLOCK_SIZE_BYTES - 1) // BLOCK_SIZE_BYTES\n\n    decrypted_data = []\n    prev_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # pad block with zeros if not full block (usually ciphertext length is multiple of block size,\n        # but just to be safe and consistent with the aes_ctr_decrypt approach)\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR with previous ciphertext block or iv to get plaintext block\n        plaintext_block = xor(decrypted_block, prev_block)\n        decrypted_data += plaintext_block\n\n        prev_block = block\n\n    # truncate to original data length in case of padding in last block\n    return decrypted_data[:len(data)]\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom youtube_dl.aes import xor, aes_decrypt, key_expansion\nfrom math import ceil\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    prev_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # If block is shorter than BLOCK_SIZE_BYTES, pad with zeros (should be rare in CBC decryption)\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        # Decrypt the current block\n        decrypted_block = aes_decrypt(block, expanded_key)\n\n        # XOR with previous ciphertext block (or IV for first block)\n        plain_block = xor(decrypted_block, prev_block)\n\n        decrypted_data += plain_block\n\n        # Update prev_block to current ciphertext block\n        prev_block = block\n\n    # Truncate plaintext to original data length\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom youtube_dl.aes import xor, aes_decrypt, key_expansion\nfrom math import ceil\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Pad incomplete block with zeros if necessary\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        plaintext_block = xor(decrypted_block, previous_block)\n\n        decrypted_data += plaintext_block\n        previous_block = block\n\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import xor, aes_decrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Pad incomplete blocks with zeros (if any)\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        plain_block = xor(decrypted_block, previous_block)\n        decrypted_data += plain_block\n        previous_block = block\n\n    # Trim to original data length\n    return decrypted_data[:len(data)]\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n"]}
{"task_id": 147, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from math import ceil\n\nfrom youtube_dl.aes import key_expansion, aes_encrypt, xor\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding: padding length = block_size - (len(data) % block_size)\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [padding_len] * padding_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # XOR plaintext block with previous cipher block (or IV for first block)\n        xor_block = xor(block, previous_cipher_block)\n\n        # Encrypt the XORed block\n        cipher_block = aes_encrypt(xor_block, expanded_key)\n\n        encrypted_data.extend(cipher_block)\n        previous_cipher_block = cipher_block\n\n    return encrypted_data", "from math import ceil\nfrom youtube_dl.aes import xor, aes_encrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding: pad to multiple of BLOCK_SIZE_BYTES\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    # If data is already a multiple of BLOCK_SIZE_BYTES, add a full block of padding\n    if padding_len == 0:\n        padding_len = BLOCK_SIZE_BYTES\n    padding = [padding_len] * padding_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    prev_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES : (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR plaintext block with previous ciphertext (or IV for first block)\n        xor_block = xor(block, prev_block)\n        # Encrypt the block\n        encrypted_block = aes_encrypt(xor_block, expanded_key)\n        encrypted_data += encrypted_block\n        prev_block = encrypted_block\n\n    return encrypted_data", "from math import ceil\nfrom youtube_dl.aes import xor, aes_encrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # Apply PKCS#7 padding\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [padding_len] * padding_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Ensure block is exactly BLOCK_SIZE_BYTES (should be guaranteed by padding)\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [padding_len] * (BLOCK_SIZE_BYTES - len(block))\n\n        # XOR plaintext block with previous ciphertext (or IV for first block)\n        xored_block = xor(block, previous_block)\n        # Encrypt the XORed block\n        encrypted_block = aes_encrypt(xored_block, expanded_key)\n        encrypted_data += encrypted_block\n        # Update previous_block for next iteration\n        previous_block = encrypted_block\n\n    return encrypted_data", "from math import ceil\nfrom youtube_dl.aes import xor, aes_encrypt, key_expansion, BLOCK_SIZE_BYTES\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padded_data = data + [pad_len] * pad_len\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR with previous cipher block (or IV for first block)\n        block_to_encrypt = xor(block, previous_cipher_block)\n        encrypted_block = aes_encrypt(block_to_encrypt, expanded_key)\n        encrypted_data += encrypted_block\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data", "from math import ceil\n\nfrom youtube_dl.aes import xor, aes_encrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # Apply PKCS#7 padding to make data length multiple of BLOCK_SIZE_BYTES\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [pad_len] * pad_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_block = iv\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # XOR plaintext block with previous cipher block (or IV for first block)\n        xored_block = xor(block, previous_block)\n\n        # Encrypt this xored block\n        encrypted_block = aes_encrypt(xored_block, expanded_key)\n\n        encrypted_data += encrypted_block\n        previous_block = encrypted_block\n\n    return encrypted_data"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\n\nfrom youtube_dl.aes import key_expansion, aes_encrypt, xor\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding: padding length = block_size - (len(data) % block_size)\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [padding_len] * padding_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # XOR plaintext block with previous cipher block (or IV for first block)\n        xor_block = xor(block, previous_cipher_block)\n\n        # Encrypt the XORed block\n        cipher_block = aes_encrypt(xor_block, expanded_key)\n\n        encrypted_data.extend(cipher_block)\n        previous_cipher_block = cipher_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import xor, aes_encrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding: pad to multiple of BLOCK_SIZE_BYTES\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    # If data is already a multiple of BLOCK_SIZE_BYTES, add a full block of padding\n    if padding_len == 0:\n        padding_len = BLOCK_SIZE_BYTES\n    padding = [padding_len] * padding_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    prev_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES : (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR plaintext block with previous ciphertext (or IV for first block)\n        xor_block = xor(block, prev_block)\n        # Encrypt the block\n        encrypted_block = aes_encrypt(xor_block, expanded_key)\n        encrypted_data += encrypted_block\n        prev_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import xor, aes_encrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # Apply PKCS#7 padding\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [padding_len] * padding_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Ensure block is exactly BLOCK_SIZE_BYTES (should be guaranteed by padding)\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [padding_len] * (BLOCK_SIZE_BYTES - len(block))\n\n        # XOR plaintext block with previous ciphertext (or IV for first block)\n        xored_block = xor(block, previous_block)\n        # Encrypt the XORed block\n        encrypted_block = aes_encrypt(xored_block, expanded_key)\n        encrypted_data += encrypted_block\n        # Update previous_block for next iteration\n        previous_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import xor, aes_encrypt, key_expansion, BLOCK_SIZE_BYTES\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padded_data = data + [pad_len] * pad_len\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR with previous cipher block (or IV for first block)\n        block_to_encrypt = xor(block, previous_cipher_block)\n        encrypted_block = aes_encrypt(block_to_encrypt, expanded_key)\n        encrypted_data += encrypted_block\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\n\nfrom youtube_dl.aes import xor, aes_encrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # Apply PKCS#7 padding to make data length multiple of BLOCK_SIZE_BYTES\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [pad_len] * pad_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_block = iv\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # XOR plaintext block with previous cipher block (or IV for first block)\n        xored_block = xor(block, previous_block)\n\n        # Encrypt this xored block\n        encrypted_block = aes_encrypt(xored_block, expanded_key)\n\n        encrypted_data += encrypted_block\n        previous_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n"]}
{"task_id": 148, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # The length of the key determines Nk (4,6,8), number of 32-bit words comprising the key.\n    key_size = len(data)\n    if key_size == 16:\n        Nk = 4\n        Nr = 10\n    elif key_size == 24:\n        Nk = 6\n        Nr = 12\n    elif key_size == 32:\n        Nk = 8\n        Nr = 14\n    else:\n        raise ValueError(\"Invalid key size. Must be 16, 24 or 32 bytes.\")\n\n    expanded_key = data[:]\n    i = Nk\n    # Each word is 4 bytes\n    while len(expanded_key) < 4 * (Nr + 1) * 4:  # Total expanded key length in bytes\n        temp = expanded_key[-4:]\n        if i % Nk == 0:\n            temp = key_schedule_core(temp, i // Nk - 1)\n        elif Nk > 6 and i % Nk == 4:\n            # For 256-bit keys, extra sub_bytes applied\n            from youtube_dl.aes import sub_bytes\n            temp = sub_bytes(temp)\n\n        # XOR with word Nk positions before\n        for j in range(4):\n            temp[j] ^= expanded_key[-4 * Nk + j]\n\n        expanded_key += temp\n        i += 1\n\n    return expanded_key[:4 * (Nr + 1) * 4]", "from youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_size = len(data)\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Key must be 16, 24 or 32 bytes long\")\n\n    # Number of 4-byte words in the key\n    Nk = key_size // 4\n    # Number of rounds depends on key size\n    Nr = {4:10, 6:12, 8:14}[Nk]\n    Nb = 4  # block size in words\n\n    expanded_key = list(data)\n    i = Nk\n    rcon_iteration = 1\n\n    while len(expanded_key) < Nb * (Nr + 1) * 4:\n        temp = expanded_key[-4:]\n\n        if i % Nk == 0:\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        elif Nk > 6 and i % Nk == 4:\n            from youtube_dl.aes import sub_bytes\n            temp = sub_bytes(temp)\n\n        # XOR temp with the [i-Nk]th 4-byte word\n        for j in range(4):\n            temp[j] ^= expanded_key[-Nk*4 + j]\n        expanded_key.extend(temp)\n        i += 1\n\n    return expanded_key", "from youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_size = len(data)\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Invalid key size: must be 16, 24 or 32 bytes\")\n\n    # Number of 32-bit words comprising the key\n    Nk = key_size // 4\n    # Number of 32-bit words in the expanded key\n    Nb = 4\n    Nr = {4:10, 6:12, 8:14}[Nk]  # Number of rounds\n    expanded_key_size = Nb * (Nr + 1) * 4  # bytes\n\n    expanded_key = list(data)\n    rcon_iteration = 1\n\n    while len(expanded_key) < expanded_key_size:\n        t = expanded_key[-4:]  # last 4 bytes\n\n        if len(expanded_key) % (Nk * 4) == 0:\n            t = key_schedule_core(t, rcon_iteration)\n            rcon_iteration += 1\n        elif Nk > 6 and (len(expanded_key) % (Nk * 4) == 16):\n            # For 256-bit keys, extra sub_bytes at certain step\n            from youtube_dl.aes import sub_bytes\n            t = sub_bytes(t)\n\n        prev_bytes = expanded_key[-Nk*4 : -Nk*4 + 4]\n        t = xor(t, prev_bytes)\n        expanded_key.extend(t)\n\n    return expanded_key", "from youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Length of original key determines number of rounds and key size\n    key_size = len(data)  # 16 / 24 / 32\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    # Determine the number of 4-byte words in the key\n    n_k = key_size // 4\n    # Determine the total number of 4-byte words in expanded key (Nb = 4 words per block, Nr depends on key size)\n    if key_size == 16:\n        n_r = 10\n    elif key_size == 24:\n        n_r = 12\n    else:  # key_size == 32\n        n_r = 14\n    n_w = 4 * (n_r + 1)  # total 4-byte words of key schedule\n\n    # The expanded keys array (list of ints)\n    expanded_key = list(data)\n    i = n_k\n\n    while i < n_w * 4:\n        # Get the previous 4-byte word\n        t = expanded_key[i - 4:i]\n\n        if i % n_k == 0:\n            t = key_schedule_core(t, i // n_k - 1)\n        elif n_k > 6 and i % n_k == 4:\n            # For 256-bit keys, extra sub_bytes step every 4th word\n            from youtube_dl.aes import sub_bytes\n            t = sub_bytes(t)\n\n        # XOR with the word n_k positions before\n        prev_word = expanded_key[i - n_k * 4: i - (n_k - 1) * 4]\n        # prev_word is 4 bytes, t is 4 bytes - perform xor element-wise\n        t = xor(t, prev_word)\n\n        expanded_key.extend(t)\n        i += 4\n\n    return expanded_key", "from youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_size = len(data)\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    # The expanded key length depends on the key size:\n    # 16 bytes key -> 176 bytes expanded key (11 * 16)\n    # 24 bytes key -> 208 bytes expanded key (13 * 16)\n    # 32 bytes key -> 240 bytes expanded key (15 * 16)\n    expanded_key_size = {16: 176, 24: 208, 32: 240}[key_size]\n    expanded_key = data[:]  # start with original key bytes\n\n    rcon_iteration = 1\n    while len(expanded_key) < expanded_key_size:\n        # Take the last 4 bytes\n        temp = expanded_key[-4:]\n\n        if len(expanded_key) % key_size == 0:\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        elif key_size == 32 and (len(expanded_key) % key_size) == 16:\n            # For 32-byte keys, perform sub_bytes on temp every 16 bytes\n            from youtube_dl.aes import sub_bytes\n            temp = sub_bytes(temp)\n\n        # XOR temp with 4 bytes block key_size bytes before\n        block_to_xor = expanded_key[-key_size:]\n        for i in range(4):\n            temp[i] ^= block_to_xor[i]\n\n        expanded_key += temp\n\n    return expanded_key[:expanded_key_size]"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\nfrom youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # The length of the key determines Nk (4,6,8), number of 32-bit words comprising the key.\n    key_size = len(data)\n    if key_size == 16:\n        Nk = 4\n        Nr = 10\n    elif key_size == 24:\n        Nk = 6\n        Nr = 12\n    elif key_size == 32:\n        Nk = 8\n        Nr = 14\n    else:\n        raise ValueError(\"Invalid key size. Must be 16, 24 or 32 bytes.\")\n\n    expanded_key = data[:]\n    i = Nk\n    # Each word is 4 bytes\n    while len(expanded_key) < 4 * (Nr + 1) * 4:  # Total expanded key length in bytes\n        temp = expanded_key[-4:]\n        if i % Nk == 0:\n            temp = key_schedule_core(temp, i // Nk - 1)\n        elif Nk > 6 and i % Nk == 4:\n            # For 256-bit keys, extra sub_bytes applied\n            from youtube_dl.aes import sub_bytes\n            temp = sub_bytes(temp)\n\n        # XOR with word Nk positions before\n        for j in range(4):\n            temp[j] ^= expanded_key[-4 * Nk + j]\n\n        expanded_key += temp\n        i += 1\n\n    return expanded_key[:4 * (Nr + 1) * 4]\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\nfrom youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_size = len(data)\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Key must be 16, 24 or 32 bytes long\")\n\n    # Number of 4-byte words in the key\n    Nk = key_size // 4\n    # Number of rounds depends on key size\n    Nr = {4:10, 6:12, 8:14}[Nk]\n    Nb = 4  # block size in words\n\n    expanded_key = list(data)\n    i = Nk\n    rcon_iteration = 1\n\n    while len(expanded_key) < Nb * (Nr + 1) * 4:\n        temp = expanded_key[-4:]\n\n        if i % Nk == 0:\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        elif Nk > 6 and i % Nk == 4:\n            from youtube_dl.aes import sub_bytes\n            temp = sub_bytes(temp)\n\n        # XOR temp with the [i-Nk]th 4-byte word\n        for j in range(4):\n            temp[j] ^= expanded_key[-Nk*4 + j]\n        expanded_key.extend(temp)\n        i += 1\n\n    return expanded_key\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\nfrom youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_size = len(data)\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Invalid key size: must be 16, 24 or 32 bytes\")\n\n    # Number of 32-bit words comprising the key\n    Nk = key_size // 4\n    # Number of 32-bit words in the expanded key\n    Nb = 4\n    Nr = {4:10, 6:12, 8:14}[Nk]  # Number of rounds\n    expanded_key_size = Nb * (Nr + 1) * 4  # bytes\n\n    expanded_key = list(data)\n    rcon_iteration = 1\n\n    while len(expanded_key) < expanded_key_size:\n        t = expanded_key[-4:]  # last 4 bytes\n\n        if len(expanded_key) % (Nk * 4) == 0:\n            t = key_schedule_core(t, rcon_iteration)\n            rcon_iteration += 1\n        elif Nk > 6 and (len(expanded_key) % (Nk * 4) == 16):\n            # For 256-bit keys, extra sub_bytes at certain step\n            from youtube_dl.aes import sub_bytes\n            t = sub_bytes(t)\n\n        prev_bytes = expanded_key[-Nk*4 : -Nk*4 + 4]\n        t = xor(t, prev_bytes)\n        expanded_key.extend(t)\n\n    return expanded_key\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\nfrom youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Length of original key determines number of rounds and key size\n    key_size = len(data)  # 16 / 24 / 32\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    # Determine the number of 4-byte words in the key\n    n_k = key_size // 4\n    # Determine the total number of 4-byte words in expanded key (Nb = 4 words per block, Nr depends on key size)\n    if key_size == 16:\n        n_r = 10\n    elif key_size == 24:\n        n_r = 12\n    else:  # key_size == 32\n        n_r = 14\n    n_w = 4 * (n_r + 1)  # total 4-byte words of key schedule\n\n    # The expanded keys array (list of ints)\n    expanded_key = list(data)\n    i = n_k\n\n    while i < n_w * 4:\n        # Get the previous 4-byte word\n        t = expanded_key[i - 4:i]\n\n        if i % n_k == 0:\n            t = key_schedule_core(t, i // n_k - 1)\n        elif n_k > 6 and i % n_k == 4:\n            # For 256-bit keys, extra sub_bytes step every 4th word\n            from youtube_dl.aes import sub_bytes\n            t = sub_bytes(t)\n\n        # XOR with the word n_k positions before\n        prev_word = expanded_key[i - n_k * 4: i - (n_k - 1) * 4]\n        # prev_word is 4 bytes, t is 4 bytes - perform xor element-wise\n        t = xor(t, prev_word)\n\n        expanded_key.extend(t)\n        i += 4\n\n    return expanded_key\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\nfrom youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_size = len(data)\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    # The expanded key length depends on the key size:\n    # 16 bytes key -> 176 bytes expanded key (11 * 16)\n    # 24 bytes key -> 208 bytes expanded key (13 * 16)\n    # 32 bytes key -> 240 bytes expanded key (15 * 16)\n    expanded_key_size = {16: 176, 24: 208, 32: 240}[key_size]\n    expanded_key = data[:]  # start with original key bytes\n\n    rcon_iteration = 1\n    while len(expanded_key) < expanded_key_size:\n        # Take the last 4 bytes\n        temp = expanded_key[-4:]\n\n        if len(expanded_key) % key_size == 0:\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        elif key_size == 32 and (len(expanded_key) % key_size) == 16:\n            # For 32-byte keys, perform sub_bytes on temp every 16 bytes\n            from youtube_dl.aes import sub_bytes\n            temp = sub_bytes(temp)\n\n        # XOR temp with 4 bytes block key_size bytes before\n        block_to_xor = expanded_key[-key_size:]\n        for i in range(4):\n            temp[i] ^= block_to_xor[i]\n\n        expanded_key += temp\n\n    return expanded_key[:expanded_key_size]\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n"]}
{"task_id": 149, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from youtube_dl.aes import xor, sub_bytes, shift_rows, mix_columns\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of 4-byte words in the key (Nk) and the number of rounds (Nr) depends on expanded_key length:\n    # Expanded key length: 176 bytes -> 11 rounds (AES-128)\n    #                      208 bytes -> 13 rounds (AES-192)\n    #                      240 bytes -> 15 rounds (AES-256)\n    # key schedule words: expanded_key length / 4\n    # rounds = (key_schedule_words / 4) - 1\n    key_schedule_words = len(expanded_key) // 4\n    rounds = key_schedule_words // 4 - 1\n\n    state = data[:]\n\n    # Initial AddRoundKey (round 0)\n    round_key = expanded_key[0:16]\n    state = xor(state, round_key)\n\n    # Rounds 1 to Nr - 1\n    for round in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        round_key = expanded_key[round * 16 : (round + 1) * 16]\n        state = xor(state, round_key)\n\n    # Final round (without mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key = expanded_key[rounds * 16 : (rounds + 1) * 16]\n    state = xor(state, round_key)\n\n    return state", "from youtube_dl.aes import xor, sub_bytes, shift_rows, mix_columns\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on expanded_key length:\n    # 16-byte key -> 10 rounds (AES-128)\n    # 24-byte key -> 12 rounds (AES-192)\n    # 32-byte key -> 14 rounds (AES-256)\n    # expanded_key size:\n    #   176 bytes = 11 round keys * 16 bytes  10 rounds\n    #   208 bytes = 13 round keys * 16 bytes  12 rounds\n    #   240 bytes = 15 round keys * 16 bytes  14 rounds\n    \n    # Calculate rounds count:\n    round_key_count = len(expanded_key) // 16\n    rounds = round_key_count - 1  # rounds count (Nr), round keys = Nr + 1\n\n    state = data[:]\n\n    def get_round_key(round):\n        start = round * 16\n        end = start + 16\n        return expanded_key[start:end]\n\n    # Initial AddRoundKey\n    state = xor(state, get_round_key(0))\n\n    # Nr-1 rounds: SubBytes, ShiftRows, MixColumns, AddRoundKey\n    for round in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = xor(state, get_round_key(round))\n\n    # Final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = xor(state, get_round_key(rounds))\n\n    return state", "from youtube_dl.aes import xor, shift_rows, sub_bytes, mix_columns\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    state = data[:]\n    key_size_bytes = len(expanded_key) * 4 // 44  # Approximate key size by expanded key length\n    # Actually expanded_key sizes:\n    # 16 bytes key -> 176 bytes expanded key (11 rounds)\n    # 24 bytes key -> 208 bytes expanded key (13 rounds)\n    # 32 bytes key -> 240 bytes expanded key (15 rounds)\n    # Number of rounds:\n    rounds = {176: 10, 208: 12, 240: 14}[len(expanded_key)]\n\n    # Initial round key addition\n    state = xor(state, expanded_key[:16])\n\n    # Rounds 1 to rounds-1\n    for round_idx in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        round_key_start = round_idx * 16\n        state = xor(state, expanded_key[round_key_start:round_key_start + 16])\n\n    # Final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = rounds * 16\n    state = xor(state, expanded_key[round_key_start:round_key_start + 16])\n\n    return state", "from youtube_dl.aes import xor, shift_rows, sub_bytes, mix_columns\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # AES parameters derived from expanded_key length (key size in words)\n    # Number of rounds = Nk + 6, where Nk is key length in 32-bit words (4 bytes each)\n    # expanded_key size in bytes: 176 (AES-128: Nk=4), 208 (AES-192: Nk=6), 240 (AES-256: Nk=8)\n    if len(expanded_key) == 176:\n        rounds = 10\n    elif len(expanded_key) == 208:\n        rounds = 12\n    elif len(expanded_key) == 240:\n        rounds = 14\n    else:\n        raise ValueError(\"Expanded key has invalid length\")\n\n    # Start with initial round key addition (AddRoundKey)\n    state = xor(data, expanded_key[:16])\n\n    # Perform main rounds\n    for round_idx in range(1, rounds):\n        # SubBytes step\n        state = sub_bytes(state)\n        # ShiftRows step\n        state = shift_rows(state)\n        # MixColumns step\n        state = mix_columns(state)\n        # AddRoundKey step\n        round_key_start = round_idx * 16\n        round_key_end = round_key_start + 16\n        state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    # Final round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = rounds * 16\n    round_key_end = round_key_start + 16\n    state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    return state", "from .aes import xor, sub_bytes, shift_rows, mix_columns\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    state = data[:]  # copy\n    key_size_bytes = len(expanded_key) * 16 // 176 if len(expanded_key) in (176, 208, 240) else 16\n    # Determine Nk and Nr based on key length\n    # Nk = number of 4-byte words in key\n    # Nr = number of rounds\n    Nk = key_size_bytes // 4\n    if Nk == 4:\n        Nr = 10\n    elif Nk == 6:\n        Nr = 12\n    elif Nk == 8:\n        Nr = 14\n    else:\n        # fallback to standard AES-128 rounds if unknown, though the provided expanded_key sizes align with those three\n        Nr = 10\n\n    # Initial round key addition\n    state = xor(state, expanded_key[0:16])\n\n    for round in range(1, Nr):\n        # SubBytes\n        state = sub_bytes(state)\n        # ShiftRows\n        state = shift_rows(state)\n        # MixColumns\n        state = mix_columns(state)\n        # AddRoundKey\n        round_key_start = round * 16\n        round_key_end = round_key_start + 16\n        state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    # Final round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = Nr * 16\n    round_key_end = round_key_start + 16\n    state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    return state"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom youtube_dl.aes import xor, sub_bytes, shift_rows, mix_columns\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of 4-byte words in the key (Nk) and the number of rounds (Nr) depends on expanded_key length:\n    # Expanded key length: 176 bytes -> 11 rounds (AES-128)\n    #                      208 bytes -> 13 rounds (AES-192)\n    #                      240 bytes -> 15 rounds (AES-256)\n    # key schedule words: expanded_key length / 4\n    # rounds = (key_schedule_words / 4) - 1\n    key_schedule_words = len(expanded_key) // 4\n    rounds = key_schedule_words // 4 - 1\n\n    state = data[:]\n\n    # Initial AddRoundKey (round 0)\n    round_key = expanded_key[0:16]\n    state = xor(state, round_key)\n\n    # Rounds 1 to Nr - 1\n    for round in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        round_key = expanded_key[round * 16 : (round + 1) * 16]\n        state = xor(state, round_key)\n\n    # Final round (without mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key = expanded_key[rounds * 16 : (rounds + 1) * 16]\n    state = xor(state, round_key)\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom youtube_dl.aes import xor, sub_bytes, shift_rows, mix_columns\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on expanded_key length:\n    # 16-byte key -> 10 rounds (AES-128)\n    # 24-byte key -> 12 rounds (AES-192)\n    # 32-byte key -> 14 rounds (AES-256)\n    # expanded_key size:\n    #   176 bytes = 11 round keys * 16 bytes  10 rounds\n    #   208 bytes = 13 round keys * 16 bytes  12 rounds\n    #   240 bytes = 15 round keys * 16 bytes  14 rounds\n    \n    # Calculate rounds count:\n    round_key_count = len(expanded_key) // 16\n    rounds = round_key_count - 1  # rounds count (Nr), round keys = Nr + 1\n\n    state = data[:]\n\n    def get_round_key(round):\n        start = round * 16\n        end = start + 16\n        return expanded_key[start:end]\n\n    # Initial AddRoundKey\n    state = xor(state, get_round_key(0))\n\n    # Nr-1 rounds: SubBytes, ShiftRows, MixColumns, AddRoundKey\n    for round in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = xor(state, get_round_key(round))\n\n    # Final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = xor(state, get_round_key(rounds))\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom youtube_dl.aes import xor, shift_rows, sub_bytes, mix_columns\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    state = data[:]\n    key_size_bytes = len(expanded_key) * 4 // 44  # Approximate key size by expanded key length\n    # Actually expanded_key sizes:\n    # 16 bytes key -> 176 bytes expanded key (11 rounds)\n    # 24 bytes key -> 208 bytes expanded key (13 rounds)\n    # 32 bytes key -> 240 bytes expanded key (15 rounds)\n    # Number of rounds:\n    rounds = {176: 10, 208: 12, 240: 14}[len(expanded_key)]\n\n    # Initial round key addition\n    state = xor(state, expanded_key[:16])\n\n    # Rounds 1 to rounds-1\n    for round_idx in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        round_key_start = round_idx * 16\n        state = xor(state, expanded_key[round_key_start:round_key_start + 16])\n\n    # Final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = rounds * 16\n    state = xor(state, expanded_key[round_key_start:round_key_start + 16])\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom youtube_dl.aes import xor, shift_rows, sub_bytes, mix_columns\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # AES parameters derived from expanded_key length (key size in words)\n    # Number of rounds = Nk + 6, where Nk is key length in 32-bit words (4 bytes each)\n    # expanded_key size in bytes: 176 (AES-128: Nk=4), 208 (AES-192: Nk=6), 240 (AES-256: Nk=8)\n    if len(expanded_key) == 176:\n        rounds = 10\n    elif len(expanded_key) == 208:\n        rounds = 12\n    elif len(expanded_key) == 240:\n        rounds = 14\n    else:\n        raise ValueError(\"Expanded key has invalid length\")\n\n    # Start with initial round key addition (AddRoundKey)\n    state = xor(data, expanded_key[:16])\n\n    # Perform main rounds\n    for round_idx in range(1, rounds):\n        # SubBytes step\n        state = sub_bytes(state)\n        # ShiftRows step\n        state = shift_rows(state)\n        # MixColumns step\n        state = mix_columns(state)\n        # AddRoundKey step\n        round_key_start = round_idx * 16\n        round_key_end = round_key_start + 16\n        state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    # Final round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = rounds * 16\n    round_key_end = round_key_start + 16\n    state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom .aes import xor, sub_bytes, shift_rows, mix_columns\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    state = data[:]  # copy\n    key_size_bytes = len(expanded_key) * 16 // 176 if len(expanded_key) in (176, 208, 240) else 16\n    # Determine Nk and Nr based on key length\n    # Nk = number of 4-byte words in key\n    # Nr = number of rounds\n    Nk = key_size_bytes // 4\n    if Nk == 4:\n        Nr = 10\n    elif Nk == 6:\n        Nr = 12\n    elif Nk == 8:\n        Nr = 14\n    else:\n        # fallback to standard AES-128 rounds if unknown, though the provided expanded_key sizes align with those three\n        Nr = 10\n\n    # Initial round key addition\n    state = xor(state, expanded_key[0:16])\n\n    for round in range(1, Nr):\n        # SubBytes\n        state = sub_bytes(state)\n        # ShiftRows\n        state = shift_rows(state)\n        # MixColumns\n        state = mix_columns(state)\n        # AddRoundKey\n        round_key_start = round * 16\n        round_key_end = round_key_start + 16\n        state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    # Final round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = Nr * 16\n    round_key_end = round_key_start + 16\n    state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n"]}
{"task_id": 150, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from youtube_dl.aes import xor, shift_rows_inv, sub_bytes_inv, mix_columns_inv\nfrom math import ceil\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES:(rounds + 1) * BLOCK_SIZE_BYTES])\n    for i in range(rounds - 1, -1, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES:(i + 1) * BLOCK_SIZE_BYTES])\n        if i != 0:\n            data = mix_columns_inv(data)\n\n    return data", "from youtube_dl.aes import xor, sub_bytes_inv, shift_rows_inv, mix_columns_inv\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16:(rounds + 1) * 16])\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * 16:(i + 1) * 16])\n        data = mix_columns_inv(data)\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:16])\n\n    return data", "from youtube_dl.aes import xor, sub_bytes_inv, shift_rows_inv, mix_columns_inv\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16: (rounds + 1) * 16])\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * 16: (i + 1) * 16])\n        data = mix_columns_inv(data)\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:16])\n\n    return data", "from youtube_dl.aes import xor, shift_rows_inv, sub_bytes_inv, mix_columns_inv\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16:(rounds + 1) * 16])\n    for i in range(rounds - 1, -1, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * 16:(i + 1) * 16])\n        if i != 0:\n            data = mix_columns_inv(data)\n\n    return data", "from youtube_dl.aes import xor, shift_rows_inv, sub_bytes_inv, mix_columns_inv\nfrom math import ceil\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Initial AddRoundKey step\n    state = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES:(rounds + 1) * BLOCK_SIZE_BYTES])\n\n    # Perform rounds in reverse order from rounds-1 down to 1\n    for round_index in range(rounds - 1, 0, -1):\n        state = shift_rows_inv(state)\n        state = sub_bytes_inv(state)\n        state = xor(state, expanded_key[round_index * BLOCK_SIZE_BYTES:(round_index + 1) * BLOCK_SIZE_BYTES])\n        state = mix_columns_inv(state)\n\n    # Final round (round 0)\n    state = shift_rows_inv(state)\n    state = sub_bytes_inv(state)\n    state = xor(state, expanded_key[0:BLOCK_SIZE_BYTES])\n\n    return state"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom youtube_dl.aes import xor, shift_rows_inv, sub_bytes_inv, mix_columns_inv\nfrom math import ceil\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES:(rounds + 1) * BLOCK_SIZE_BYTES])\n    for i in range(rounds - 1, -1, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES:(i + 1) * BLOCK_SIZE_BYTES])\n        if i != 0:\n            data = mix_columns_inv(data)\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom youtube_dl.aes import xor, sub_bytes_inv, shift_rows_inv, mix_columns_inv\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16:(rounds + 1) * 16])\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * 16:(i + 1) * 16])\n        data = mix_columns_inv(data)\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:16])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom youtube_dl.aes import xor, sub_bytes_inv, shift_rows_inv, mix_columns_inv\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16: (rounds + 1) * 16])\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * 16: (i + 1) * 16])\n        data = mix_columns_inv(data)\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:16])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom youtube_dl.aes import xor, shift_rows_inv, sub_bytes_inv, mix_columns_inv\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16:(rounds + 1) * 16])\n    for i in range(rounds - 1, -1, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * 16:(i + 1) * 16])\n        if i != 0:\n            data = mix_columns_inv(data)\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom youtube_dl.aes import xor, shift_rows_inv, sub_bytes_inv, mix_columns_inv\nfrom math import ceil\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Initial AddRoundKey step\n    state = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES:(rounds + 1) * BLOCK_SIZE_BYTES])\n\n    # Perform rounds in reverse order from rounds-1 down to 1\n    for round_index in range(rounds - 1, 0, -1):\n        state = shift_rows_inv(state)\n        state = sub_bytes_inv(state)\n        state = xor(state, expanded_key[round_index * BLOCK_SIZE_BYTES:(round_index + 1) * BLOCK_SIZE_BYTES])\n        state = mix_columns_inv(state)\n\n    # Final round (round 0)\n    state = shift_rows_inv(state)\n    state = sub_bytes_inv(state)\n    state = xor(state, expanded_key[0:BLOCK_SIZE_BYTES])\n\n    return state\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n"]}
{"task_id": 151, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\nfrom youtube_dl.aes import aes_encrypt, aes_ctr_decrypt, key_expansion, inc\n\n\nclass AESCounter:\n    \"\"\"\n    Counter class for AES CTR mode decryption.\n    The counter block is 16 bytes:\n    - First 8 bytes: fixed (the high bytes from the data)\n    - Last 8 bytes: incrementing (starting at 0)\n    \"\"\"\n    def __init__(self, fixed_counter):\n        # fixed_counter is a list of 8 ints (the first 8 bytes)\n        self.fixed_counter = fixed_counter\n        self.counter = [0] * 8  # 8 bytes for the incrementing counter\n    \n    def next_value(self):\n        # Compose the 16-byte counter block\n        block = self.fixed_counter + self.counter\n        # Increment the last 8 bytes counter\n        self.counter = inc(self.counter)\n        return block\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Decode base64 data to bytes, then to int list\n    decoded_bytes = compat_b64decode(data)\n    decoded_ints = bytes_to_intlist(decoded_bytes)\n\n    # The first 8 bytes of decoded data are the high bytes of the counter\n    if len(decoded_ints) < 8:\n        raise ValueError('Decoded data is too short to extract counter bytes.')\n    fixed_counter = decoded_ints[:8]\n\n    # Prepare password bytes and convert to int list\n    password_bytes = password.encode('utf-8')\n    password_ints = bytes_to_intlist(password_bytes)\n\n    # The key is first 'key_size_bytes' bytes from password (zero-padded if needed)\n    key = password_ints[:key_size_bytes]\n    if len(key) < key_size_bytes:\n        key += [0] * (key_size_bytes - len(key))\n\n    # The first 16 bytes of password (zero-padded if needed) is the block to encrypt\n    block_to_encrypt = password_ints[:16]\n    if len(block_to_encrypt) < 16:\n        block_to_encrypt += [0] * (16 - len(block_to_encrypt))\n\n    # Encrypt this block with the cipher key to get the actual key\n    expanded_key = key_expansion(key)\n    cipher_key = aes_encrypt(block_to_encrypt, expanded_key)\n\n    # Create counter instance with fixed_counter for CTR mode\n    counter = AESCounter(fixed_counter)\n\n    # The ciphertext to decrypt excludes the first 8 bytes (the fixed_counter)\n    ciphertext = decoded_ints[8:]\n\n    # Decrypt with aes in counter mode using the cipher_key\n    decrypted_ints = aes_ctr_decrypt(ciphertext, cipher_key, counter)\n\n    # Convert decrypted ints to bytes then decode to string (utf-8)\n    decrypted_bytes = intlist_to_bytes(decrypted_ints)\n    decrypted_text = decrypted_bytes.decode('utf-8', errors='replace')\n\n    return decrypted_text", "from youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\nfrom youtube_dl.aes import aes_encrypt, aes_ctr_decrypt, key_expansion, inc\n\n\nclass Counter:\n    \"\"\"\n    Counter class for AES CTR mode.\n    It holds a 16-byte counter block where the first 8 bytes are fixed (high bytes)\n    and the last 8 bytes increment for each counter block.\n    \"\"\"\n\n    def __init__(self, high_bytes):\n        # high_bytes: list of 8 ints\n        self.high_bytes = high_bytes\n        self.low_bytes = [0] * 8\n\n    def next_value(self):\n        # Compose the counter block: high_bytes + low_bytes\n        counter_block = self.high_bytes + self.low_bytes\n        # Increment the low_bytes counter for the next call\n        self.low_bytes = inc(self.low_bytes)\n        return counter_block\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Decode data from base64 to bytes, then to int list\n    decoded_bytes = compat_b64decode(data)\n    decoded = bytes_to_intlist(decoded_bytes)\n\n    # Extract the first 8 bytes of decoded data as the high bytes of the counter\n    high_bytes = decoded[:8]\n\n    # The rest of the data is the encrypted payload (after the 8 high bytes)\n    cipher_data = decoded[8:]\n\n    # Prepare the password key material\n    pw_bytes = password.encode('utf-8')\n    pw_ints = bytes_to_intlist(pw_bytes)\n\n    # Take the first key_size_bytes from password, pad with zeros if needed\n    key_part = pw_ints[:key_size_bytes]\n    if len(key_part) < key_size_bytes:\n        key_part += [0] * (key_size_bytes - len(key_part))\n\n    # Take the first 16 bytes of password as plain data, pad with zeros if short\n    plain_block = pw_ints[:16]\n    if len(plain_block) < 16:\n        plain_block += [0] * (16 - len(plain_block))\n\n    # Expand the key for encryption\n    expanded_key = key_expansion(key_part)\n\n    # Encrypt the plain_block with expanded key to generate the cipher key\n    cipher_key = aes_encrypt(plain_block, expanded_key)\n    # cipher_key is 16 bytes, but key_size_bytes may be more. Combine accordingly:\n    # Since cipher_key length = 16, but key_size_bytes can be 16/24/32\n    # Per description the cipher key is the encryption of the first 16 bytes of password with the first key_size_bytes of password (if need filled zeros).\n    # It's ambiguous on what to do if key_size_bytes != 16, the encrypted block is 16 bytes only.\n    # But since key expansion and other functions expect key_size_bytes, we assume cipher_key is length 16 and truncated or padded as needed.\n    # So for key_size_bytes > 16, we fill cipher_key to key_size_bytes:\n    if key_size_bytes > 16:\n        cipher_key += [0] * (key_size_bytes - 16)\n    elif key_size_bytes < 16:\n        cipher_key = cipher_key[:key_size_bytes]\n\n    # Initialize the counter with the extracted high bytes\n    counter = Counter(high_bytes)\n\n    # Decrypt the cipher_data using AES CTR mode with the cipher_key\n    decrypted_ints = aes_ctr_decrypt(cipher_data, cipher_key, counter)\n\n    # Convert decrypted int list to bytes, then decode utf-8 text\n    decrypted_bytes = intlist_to_bytes(decrypted_ints)\n    return decrypted_bytes.decode('utf-8', errors='replace')", "from math import ceil\nfrom youtube_dl.aes import aes_encrypt, key_expansion, aes_ctr_decrypt\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\nfrom youtube_dl.compat import compat_b64decode\n\n\nclass Counter:\n    \"\"\"\n    Counter instance for AES CTR mode.\n    It maintains a 16-byte counter block. The first 8 bytes remain fixed (high bytes),\n    the last 8 bytes incremented for each next_value call.\n    \"\"\"\n\n    def __init__(self, high_bytes):\n        # high_bytes: list of 8 ints, the 8 high bytes of counter from data\n        self.high_bytes = high_bytes\n        # low_bytes counter starts at zero (8 bytes)\n        self.low_bytes = [0] * 8\n\n    def next_value(self):\n        # Compose the 16-byte counter block: high_bytes + low_bytes\n        counter_block = self.high_bytes + self.low_bytes\n        # Increment the low_bytes part (like a 64-bit integer)\n        self._inc_low_bytes()\n        return counter_block\n\n    def _inc_low_bytes(self):\n        # Increment the low_bytes with carry\n        for i in range(7, -1, -1):\n            if self.low_bytes[i] == 255:\n                self.low_bytes[i] = 0\n            else:\n                self.low_bytes[i] += 1\n                break\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Step 1: Base64 decode 'data' to bytes\n    decoded_bytes = compat_b64decode(data)\n    decoded_ints = bytes_to_intlist(decoded_bytes)\n\n    # Extract the first 8 bytes as high bytes of counter\n    high_bytes = decoded_ints[:8]\n\n    # The cipher text is the rest of decoded data after first 8 bytes\n    cipher_data = decoded_ints[8:]\n\n    # Step 2: Prepare the cipher key\n    # Encode password to utf-8 bytes, then to int list\n    password_bytes = password.encode('utf-8')\n    password_ints = bytes_to_intlist(password_bytes)\n\n    # Take first 'key_size_bytes' from password, pad with 0 if needed\n    key_material = password_ints[:key_size_bytes]\n    if len(key_material) < key_size_bytes:\n        key_material += [0] * (key_size_bytes - len(key_material))\n\n    # The plaintext block to encrypt for key derivation is first 16 bytes of password padded with 0s\n    password_block = password_ints[:16]\n    if len(password_block) < 16:\n        password_block += [0] * (16 - len(password_block))\n\n    # Expand the key_material into the expanded key\n    expanded_key = key_expansion(key_material)\n\n    # Encrypt password_block using expanded_key to get the cipher key\n    cipher_key = aes_encrypt(password_block, expanded_key)\n\n    # Step 3: Create Counter instance for AES CTR mode\n    counter = Counter(high_bytes)\n\n    # Step 4: Decrypt cipher_data using AES CTR mode with cipher_key and counter\n    decrypted_ints = aes_ctr_decrypt(cipher_data, cipher_key, counter)\n\n    # Step 5: Convert decrypted ints to bytes then decode to UTF-8 string\n    decrypted_bytes = intlist_to_bytes(decrypted_ints)\n    decrypted_text = decrypted_bytes.decode('utf-8', errors='replace')\n\n    return decrypted_text", "from math import ceil\nfrom youtube_dl.aes import aes_encrypt, aes_ctr_decrypt, key_expansion, inc\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Step 1: Decode the base64-encoded data and convert to integer list\n    decoded_bytes = compat_b64decode(data)\n    decoded_data = bytes_to_intlist(decoded_bytes)\n\n    if len(decoded_data) < 8:\n        # Defensive: not enough data for counter prefix\n        return ''\n\n    # Step 2: Prepare password byte list\n    password_bytes = password.encode('utf-8')\n    password_ints = bytes_to_intlist(password_bytes)\n\n    # Pad or truncate password key segment to key_size_bytes\n    key_part = password_ints[:key_size_bytes]\n    if len(key_part) < key_size_bytes:\n        key_part += [0] * (key_size_bytes - len(key_part))\n\n    # Prepare the 16-byte key block by taking first 16 bytes of password (pad if needed)\n    key_block = password_ints[:16]\n    if len(key_block) < 16:\n        key_block += [0] * (16 - len(key_block))\n\n    # Step 3: Expand the input key for AES\n    expanded_key = key_expansion(key_part)\n\n    # Step 4: Encrypt the key_block with the expanded key to get the cipher key\n    cipher_key = aes_encrypt(key_block, expanded_key)  # 16 bytes\n\n    # If key_size_bytes > 16, extend cipher_key by repeating or padding zeros (not specified)\n    # The docstring implies cipher_key length == key_size_bytes, but aes_encrypt returns 16 bytes only\n    # Because key_size_bytes can be 16,24,32 but aes_encrypt output size is 16,\n    # We'll pad cipher_key with zeros if key_size_bytes > 16 to use as key for CTR decryption.\n    if key_size_bytes > 16:\n        cipher_key += [0] * (key_size_bytes - 16)\n\n    # Step 5: Construct the 16-byte initial counter block\n    # First 8 bytes: high bytes of the counter from first 8 bytes of decoded_data\n    counter_high = decoded_data[:8]\n    # Last 8 bytes: 8 zero bytes (low bytes start at zero)\n    counter_low = [0] * 8\n    initial_counter = counter_high + counter_low\n\n    # Step 6: Define a counter class instance with a next_value method for aes_ctr_decrypt\n    class Counter:\n        def __init__(self, initial):\n            self.value = initial[:]\n\n        def next_value(self):\n            # Return current counter block and increment by 1\n            current = self.value[:]\n            self.value = inc(self.value)\n            return current\n\n    counter = Counter(initial_counter)\n\n    # Step 7: The ciphertext is the decoded_data (input data)\n    cipher_data = decoded_data\n\n    # Step 8: Decrypt using aes_ctr_decrypt with the cipher key and counter instance\n    decrypted_ints = aes_ctr_decrypt(cipher_data, cipher_key[:key_size_bytes], counter)\n\n    # Convert decrypted int list back to bytes and decode as UTF-8 string (ignoring errors)\n    decrypted_bytes = intlist_to_bytes(decrypted_ints)\n    try:\n        return decrypted_bytes.decode('utf-8', errors='replace')\n    except Exception:\n        # fallback to string decode ignoring errors\n        return decrypted_bytes.decode('utf-8', errors='ignore')", "from youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\nfrom youtube_dl.aes import aes_encrypt, aes_ctr_decrypt, key_expansion, inc\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Decode base64 encoded data to bytes\n    decoded_data = compat_b64decode(data)\n\n    # Convert decoded data and password to int lists\n    decoded_data_int = bytes_to_intlist(decoded_data)\n    password_bytes = password.encode('utf-8')\n    password_int = bytes_to_intlist(password_bytes)\n\n    # Prepare cipher key input: first key_size_bytes from password, zero-padded if needed\n    cipher_key_raw = password_int[:key_size_bytes]\n    if len(cipher_key_raw) < key_size_bytes:\n        cipher_key_raw += [0] * (key_size_bytes - len(cipher_key_raw))\n\n    # Prepare first 16 bytes of password for encryption input, pad with 0 if shorter\n    password_16 = password_int[:16]\n    if len(password_16) < 16:\n        password_16 += [0] * (16 - len(password_16))\n\n    # Expand the cipher key first\n    expanded_key = key_expansion(cipher_key_raw)\n\n    # Encrypt the 16-byte block to get the cipher key\n    cipher_key = aes_encrypt(password_16, expanded_key)\n\n    # The first 8 Bytes of decoded_data are the high bytes of the counter\n    # We construct the 16-Byte initial counter block:\n    #   first 8 bytes: from decoded_data (high bytes)\n    #   last 8 bytes: zeros (low bytes), will be incremented\n    counter_high = decoded_data_int[:8]\n    counter_low = [0] * 8\n    initial_counter = counter_high + counter_low\n\n    # Define counter instance with next_value method\n    class Counter:\n        def __init__(self, initial):\n            self.counter = initial[:]\n\n        def next_value(self):\n            value = self.counter[:]\n            # Increment the counter low bytes (the last 8 bytes)\n            # The counter as a whole is 16 bytes, incrementing the last 8 bytes as a big-endian number\n            # So we increment from index 15 backwards to 8 (last 8 bytes)\n            for i in range(15, 7, -1):\n                if self.counter[i] == 255:\n                    self.counter[i] = 0\n                else:\n                    self.counter[i] += 1\n                    break\n            return value\n\n    counter = Counter(initial_counter)\n\n    # The cipher text to decrypt is after the 8 high bytes, so from byte index 8 onwards\n    ciphertext = decoded_data_int[8:]\n\n    # Perform AES CTR decryption\n    decrypted_int = aes_ctr_decrypt(ciphertext, cipher_key, counter)\n\n    # Convert decrypted int list to bytes, then decode utf-8 to string\n    decrypted_bytes = intlist_to_bytes(decrypted_int)\n    return decrypted_bytes.decode('utf-8', errors='replace')"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\nfrom youtube_dl.aes import aes_encrypt, aes_ctr_decrypt, key_expansion, inc\n\n\nclass AESCounter:\n    \"\"\"\n    Counter class for AES CTR mode decryption.\n    The counter block is 16 bytes:\n    - First 8 bytes: fixed (the high bytes from the data)\n    - Last 8 bytes: incrementing (starting at 0)\n    \"\"\"\n    def __init__(self, fixed_counter):\n        # fixed_counter is a list of 8 ints (the first 8 bytes)\n        self.fixed_counter = fixed_counter\n        self.counter = [0] * 8  # 8 bytes for the incrementing counter\n    \n    def next_value(self):\n        # Compose the 16-byte counter block\n        block = self.fixed_counter + self.counter\n        # Increment the last 8 bytes counter\n        self.counter = inc(self.counter)\n        return block\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Decode base64 data to bytes, then to int list\n    decoded_bytes = compat_b64decode(data)\n    decoded_ints = bytes_to_intlist(decoded_bytes)\n\n    # The first 8 bytes of decoded data are the high bytes of the counter\n    if len(decoded_ints) < 8:\n        raise ValueError('Decoded data is too short to extract counter bytes.')\n    fixed_counter = decoded_ints[:8]\n\n    # Prepare password bytes and convert to int list\n    password_bytes = password.encode('utf-8')\n    password_ints = bytes_to_intlist(password_bytes)\n\n    # The key is first 'key_size_bytes' bytes from password (zero-padded if needed)\n    key = password_ints[:key_size_bytes]\n    if len(key) < key_size_bytes:\n        key += [0] * (key_size_bytes - len(key))\n\n    # The first 16 bytes of password (zero-padded if needed) is the block to encrypt\n    block_to_encrypt = password_ints[:16]\n    if len(block_to_encrypt) < 16:\n        block_to_encrypt += [0] * (16 - len(block_to_encrypt))\n\n    # Encrypt this block with the cipher key to get the actual key\n    expanded_key = key_expansion(key)\n    cipher_key = aes_encrypt(block_to_encrypt, expanded_key)\n\n    # Create counter instance with fixed_counter for CTR mode\n    counter = AESCounter(fixed_counter)\n\n    # The ciphertext to decrypt excludes the first 8 bytes (the fixed_counter)\n    ciphertext = decoded_ints[8:]\n\n    # Decrypt with aes in counter mode using the cipher_key\n    decrypted_ints = aes_ctr_decrypt(ciphertext, cipher_key, counter)\n\n    # Convert decrypted ints to bytes then decode to string (utf-8)\n    decrypted_bytes = intlist_to_bytes(decrypted_ints)\n    decrypted_text = decrypted_bytes.decode('utf-8', errors='replace')\n\n    return decrypted_text\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\nfrom youtube_dl.aes import aes_encrypt, aes_ctr_decrypt, key_expansion, inc\n\n\nclass Counter:\n    \"\"\"\n    Counter class for AES CTR mode.\n    It holds a 16-byte counter block where the first 8 bytes are fixed (high bytes)\n    and the last 8 bytes increment for each counter block.\n    \"\"\"\n\n    def __init__(self, high_bytes):\n        # high_bytes: list of 8 ints\n        self.high_bytes = high_bytes\n        self.low_bytes = [0] * 8\n\n    def next_value(self):\n        # Compose the counter block: high_bytes + low_bytes\n        counter_block = self.high_bytes + self.low_bytes\n        # Increment the low_bytes counter for the next call\n        self.low_bytes = inc(self.low_bytes)\n        return counter_block\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Decode data from base64 to bytes, then to int list\n    decoded_bytes = compat_b64decode(data)\n    decoded = bytes_to_intlist(decoded_bytes)\n\n    # Extract the first 8 bytes of decoded data as the high bytes of the counter\n    high_bytes = decoded[:8]\n\n    # The rest of the data is the encrypted payload (after the 8 high bytes)\n    cipher_data = decoded[8:]\n\n    # Prepare the password key material\n    pw_bytes = password.encode('utf-8')\n    pw_ints = bytes_to_intlist(pw_bytes)\n\n    # Take the first key_size_bytes from password, pad with zeros if needed\n    key_part = pw_ints[:key_size_bytes]\n    if len(key_part) < key_size_bytes:\n        key_part += [0] * (key_size_bytes - len(key_part))\n\n    # Take the first 16 bytes of password as plain data, pad with zeros if short\n    plain_block = pw_ints[:16]\n    if len(plain_block) < 16:\n        plain_block += [0] * (16 - len(plain_block))\n\n    # Expand the key for encryption\n    expanded_key = key_expansion(key_part)\n\n    # Encrypt the plain_block with expanded key to generate the cipher key\n    cipher_key = aes_encrypt(plain_block, expanded_key)\n    # cipher_key is 16 bytes, but key_size_bytes may be more. Combine accordingly:\n    # Since cipher_key length = 16, but key_size_bytes can be 16/24/32\n    # Per description the cipher key is the encryption of the first 16 bytes of password with the first key_size_bytes of password (if need filled zeros).\n    # It's ambiguous on what to do if key_size_bytes != 16, the encrypted block is 16 bytes only.\n    # But since key expansion and other functions expect key_size_bytes, we assume cipher_key is length 16 and truncated or padded as needed.\n    # So for key_size_bytes > 16, we fill cipher_key to key_size_bytes:\n    if key_size_bytes > 16:\n        cipher_key += [0] * (key_size_bytes - 16)\n    elif key_size_bytes < 16:\n        cipher_key = cipher_key[:key_size_bytes]\n\n    # Initialize the counter with the extracted high bytes\n    counter = Counter(high_bytes)\n\n    # Decrypt the cipher_data using AES CTR mode with the cipher_key\n    decrypted_ints = aes_ctr_decrypt(cipher_data, cipher_key, counter)\n\n    # Convert decrypted int list to bytes, then decode utf-8 text\n    decrypted_bytes = intlist_to_bytes(decrypted_ints)\n    return decrypted_bytes.decode('utf-8', errors='replace')\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import aes_encrypt, key_expansion, aes_ctr_decrypt\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\nfrom youtube_dl.compat import compat_b64decode\n\n\nclass Counter:\n    \"\"\"\n    Counter instance for AES CTR mode.\n    It maintains a 16-byte counter block. The first 8 bytes remain fixed (high bytes),\n    the last 8 bytes incremented for each next_value call.\n    \"\"\"\n\n    def __init__(self, high_bytes):\n        # high_bytes: list of 8 ints, the 8 high bytes of counter from data\n        self.high_bytes = high_bytes\n        # low_bytes counter starts at zero (8 bytes)\n        self.low_bytes = [0] * 8\n\n    def next_value(self):\n        # Compose the 16-byte counter block: high_bytes + low_bytes\n        counter_block = self.high_bytes + self.low_bytes\n        # Increment the low_bytes part (like a 64-bit integer)\n        self._inc_low_bytes()\n        return counter_block\n\n    def _inc_low_bytes(self):\n        # Increment the low_bytes with carry\n        for i in range(7, -1, -1):\n            if self.low_bytes[i] == 255:\n                self.low_bytes[i] = 0\n            else:\n                self.low_bytes[i] += 1\n                break\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Step 1: Base64 decode 'data' to bytes\n    decoded_bytes = compat_b64decode(data)\n    decoded_ints = bytes_to_intlist(decoded_bytes)\n\n    # Extract the first 8 bytes as high bytes of counter\n    high_bytes = decoded_ints[:8]\n\n    # The cipher text is the rest of decoded data after first 8 bytes\n    cipher_data = decoded_ints[8:]\n\n    # Step 2: Prepare the cipher key\n    # Encode password to utf-8 bytes, then to int list\n    password_bytes = password.encode('utf-8')\n    password_ints = bytes_to_intlist(password_bytes)\n\n    # Take first 'key_size_bytes' from password, pad with 0 if needed\n    key_material = password_ints[:key_size_bytes]\n    if len(key_material) < key_size_bytes:\n        key_material += [0] * (key_size_bytes - len(key_material))\n\n    # The plaintext block to encrypt for key derivation is first 16 bytes of password padded with 0s\n    password_block = password_ints[:16]\n    if len(password_block) < 16:\n        password_block += [0] * (16 - len(password_block))\n\n    # Expand the key_material into the expanded key\n    expanded_key = key_expansion(key_material)\n\n    # Encrypt password_block using expanded_key to get the cipher key\n    cipher_key = aes_encrypt(password_block, expanded_key)\n\n    # Step 3: Create Counter instance for AES CTR mode\n    counter = Counter(high_bytes)\n\n    # Step 4: Decrypt cipher_data using AES CTR mode with cipher_key and counter\n    decrypted_ints = aes_ctr_decrypt(cipher_data, cipher_key, counter)\n\n    # Step 5: Convert decrypted ints to bytes then decode to UTF-8 string\n    decrypted_bytes = intlist_to_bytes(decrypted_ints)\n    decrypted_text = decrypted_bytes.decode('utf-8', errors='replace')\n\n    return decrypted_text\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import aes_encrypt, aes_ctr_decrypt, key_expansion, inc\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Step 1: Decode the base64-encoded data and convert to integer list\n    decoded_bytes = compat_b64decode(data)\n    decoded_data = bytes_to_intlist(decoded_bytes)\n\n    if len(decoded_data) < 8:\n        # Defensive: not enough data for counter prefix\n        return ''\n\n    # Step 2: Prepare password byte list\n    password_bytes = password.encode('utf-8')\n    password_ints = bytes_to_intlist(password_bytes)\n\n    # Pad or truncate password key segment to key_size_bytes\n    key_part = password_ints[:key_size_bytes]\n    if len(key_part) < key_size_bytes:\n        key_part += [0] * (key_size_bytes - len(key_part))\n\n    # Prepare the 16-byte key block by taking first 16 bytes of password (pad if needed)\n    key_block = password_ints[:16]\n    if len(key_block) < 16:\n        key_block += [0] * (16 - len(key_block))\n\n    # Step 3: Expand the input key for AES\n    expanded_key = key_expansion(key_part)\n\n    # Step 4: Encrypt the key_block with the expanded key to get the cipher key\n    cipher_key = aes_encrypt(key_block, expanded_key)  # 16 bytes\n\n    # If key_size_bytes > 16, extend cipher_key by repeating or padding zeros (not specified)\n    # The docstring implies cipher_key length == key_size_bytes, but aes_encrypt returns 16 bytes only\n    # Because key_size_bytes can be 16,24,32 but aes_encrypt output size is 16,\n    # We'll pad cipher_key with zeros if key_size_bytes > 16 to use as key for CTR decryption.\n    if key_size_bytes > 16:\n        cipher_key += [0] * (key_size_bytes - 16)\n\n    # Step 5: Construct the 16-byte initial counter block\n    # First 8 bytes: high bytes of the counter from first 8 bytes of decoded_data\n    counter_high = decoded_data[:8]\n    # Last 8 bytes: 8 zero bytes (low bytes start at zero)\n    counter_low = [0] * 8\n    initial_counter = counter_high + counter_low\n\n    # Step 6: Define a counter class instance with a next_value method for aes_ctr_decrypt\n    class Counter:\n        def __init__(self, initial):\n            self.value = initial[:]\n\n        def next_value(self):\n            # Return current counter block and increment by 1\n            current = self.value[:]\n            self.value = inc(self.value)\n            return current\n\n    counter = Counter(initial_counter)\n\n    # Step 7: The ciphertext is the decoded_data (input data)\n    cipher_data = decoded_data\n\n    # Step 8: Decrypt using aes_ctr_decrypt with the cipher key and counter instance\n    decrypted_ints = aes_ctr_decrypt(cipher_data, cipher_key[:key_size_bytes], counter)\n\n    # Convert decrypted int list back to bytes and decode as UTF-8 string (ignoring errors)\n    decrypted_bytes = intlist_to_bytes(decrypted_ints)\n    try:\n        return decrypted_bytes.decode('utf-8', errors='replace')\n    except Exception:\n        # fallback to string decode ignoring errors\n        return decrypted_bytes.decode('utf-8', errors='ignore')\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\nfrom youtube_dl.aes import aes_encrypt, aes_ctr_decrypt, key_expansion, inc\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Decode base64 encoded data to bytes\n    decoded_data = compat_b64decode(data)\n\n    # Convert decoded data and password to int lists\n    decoded_data_int = bytes_to_intlist(decoded_data)\n    password_bytes = password.encode('utf-8')\n    password_int = bytes_to_intlist(password_bytes)\n\n    # Prepare cipher key input: first key_size_bytes from password, zero-padded if needed\n    cipher_key_raw = password_int[:key_size_bytes]\n    if len(cipher_key_raw) < key_size_bytes:\n        cipher_key_raw += [0] * (key_size_bytes - len(cipher_key_raw))\n\n    # Prepare first 16 bytes of password for encryption input, pad with 0 if shorter\n    password_16 = password_int[:16]\n    if len(password_16) < 16:\n        password_16 += [0] * (16 - len(password_16))\n\n    # Expand the cipher key first\n    expanded_key = key_expansion(cipher_key_raw)\n\n    # Encrypt the 16-byte block to get the cipher key\n    cipher_key = aes_encrypt(password_16, expanded_key)\n\n    # The first 8 Bytes of decoded_data are the high bytes of the counter\n    # We construct the 16-Byte initial counter block:\n    #   first 8 bytes: from decoded_data (high bytes)\n    #   last 8 bytes: zeros (low bytes), will be incremented\n    counter_high = decoded_data_int[:8]\n    counter_low = [0] * 8\n    initial_counter = counter_high + counter_low\n\n    # Define counter instance with next_value method\n    class Counter:\n        def __init__(self, initial):\n            self.counter = initial[:]\n\n        def next_value(self):\n            value = self.counter[:]\n            # Increment the counter low bytes (the last 8 bytes)\n            # The counter as a whole is 16 bytes, incrementing the last 8 bytes as a big-endian number\n            # So we increment from index 15 backwards to 8 (last 8 bytes)\n            for i in range(15, 7, -1):\n                if self.counter[i] == 255:\n                    self.counter[i] = 0\n                else:\n                    self.counter[i] += 1\n                    break\n            return value\n\n    counter = Counter(initial_counter)\n\n    # The cipher text to decrypt is after the 8 high bytes, so from byte index 8 onwards\n    ciphertext = decoded_data_int[8:]\n\n    # Perform AES CTR decryption\n    decrypted_int = aes_ctr_decrypt(ciphertext, cipher_key, counter)\n\n    # Convert decrypted int list to bytes, then decode utf-8 to string\n    decrypted_bytes = intlist_to_bytes(decrypted_int)\n    return decrypted_bytes.decode('utf-8', errors='replace')\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n"]}
{"task_id": 152, "project": "test-apps/youtube-dl", "module": "youtube_dl.downloader.f4m", "predictions": ["def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_groups = boot_info.get('fragments', [])\n    result = []\n    for segment, fragments_group in zip(segments, fragments_groups):\n        # segment_run is a list of (first_segment, fragments_per_segment)\n        segment_run = segment.get('segment_run', [])\n        for (first_segment, fragments_per_segment) in segment_run:\n            # For each segment_run entry, take the corresponding fragments\n            for i in range(fragments_per_segment):\n                fragment_index = first_segment + i - 1  # segments start counting from 1\n                # Check bounds and fetch the fragment from fragments_group\n                if 0 <= fragment_index < len(fragments_group):\n                    fragment = fragments_group[fragment_index]\n                    result.append((segment, fragment))\n    return result", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    result = []\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    for seg_idx, segment in enumerate(segments):\n        # segment_run is list of tuples (first_segment, fragments_per_segment)\n        segment_runs = segment.get('segment_run', [])\n        for fr_idx, fragments_data in enumerate(fragments_runs):\n            # Each fragments_data is a dict with a 'fragments' key (list of fragment dicts)\n            fragments = fragments_data.get('fragments', [])\n\n            # For each segment_run tuple in this segment, find fragments belonging to it.\n            for first_segment, fragments_per_segment in segment_runs:\n                # Select fragments that belong to this segment run\n                # The fragment's 'first' index should be within the segment range:\n                seg_start = first_segment\n                seg_end = first_segment + fragments_per_segment\n                # Collect matching fragments among fragments list (from fragments_data)\n                matched_fragments = [\n                    fragment\n                    for fragment in fragments\n                    if seg_start <= fragment.get('first', 0) < seg_end\n                ]\n                for fragment in matched_fragments:\n                    result.append((segment, fragment))\n\n    return result", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    # segments is a list of dicts with key 'segment_run' which is a list of (first_segment, fragments_per_segment)\n    # fragments_runs is a list of dicts with key 'fragments' which is a list of fragment dicts with 'first' integer\n\n    # We need to map each fragment to a segment.\n    # The segments list is a list of segments where each segment contains a 'segment_run' list of tuples:\n    # (first_segment_number, fragments_per_segment)\n    # The fragments list is a list of fragments runs, each with a 'fragments' list that has fragment dicts with 'first' fields (fragment number).\n\n    # We will enumerate segments and their runs to get segment index and fragment numbering.\n    # The segment_run entries give us the segment number and how many fragments it contains.\n\n    # Create a list indexed by segment number mapping to segment index in segments\n    # Actually, segments is a list of segment dicts; but each segment has multiple runs.\n    # We will combine all segment runs across segments, keeping track of which segment they belong to.\n\n    # For each segments[i] (segment), for each (first_segment, fragments_per_segment) in segment_run:\n    # We'll build a mapping of segment number to (segments index i, run index, first_segment, fragments_per_segment)\n    # Then when iterating fragments, find which segment run they belong to.\n\n    # However, the segments list itself is a list of dicts with 'segment_run' list, so it is a structure for grouping, but\n    # The fragment numbers are aligned globally.\n\n    # We'll construct a sorted list of (segment_number, segment_index, run_index, fragments_per_segment)\n    segment_run_info = []\n    for segment_index, segment in enumerate(segments):\n        for run_index, (first_segment, fragments_per_segment) in enumerate(segment['segment_run']):\n            segment_run_info.append((first_segment, segment_index, run_index, fragments_per_segment))\n\n    # Sort by first_segment\n    segment_run_info.sort(key=lambda x: x[0])\n\n    # Now iterate fragments runs and their fragments with fragment number (first)\n    # For each fragment, find which segment run it belongs to by comparing fragment number with segment_run intervals\n    # We build a list of intervals: each run covers fragment indices from first_segment to first_segment + fragments_per_segment -1\n\n    # We'll use segment_run_info and map fragment numbers to segment runs\n    # If no segment run is found, assign None\n\n    for fragments_run_index, fragments_run in enumerate(fragments_runs):\n        for fragment in fragments_run['fragments']:\n            fragment_number = fragment['first']\n\n            # Find segment run for this fragment_number\n            seg_index = None\n            run_index = None\n            for (first_segment, segment_index, run_idx, fragments_per_segment) in segment_run_info:\n                if first_segment <= fragment_number < first_segment + fragments_per_segment:\n                    seg_index = segment_index\n                    run_index = run_idx\n                    break\n\n            segment = segments[seg_index] if seg_index is not None else None\n            fragments_list.append((segment, fragment))\n\n    return fragments_list", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    result = []\n\n    for segment, fragments_run in zip(segments, fragments_runs):\n        # Each segment contains 'segment_run' list of tuples (first_segment, fragments_per_segment)\n        segment_runs = segment.get('segment_run', [])\n        \n        for first_segment, fragments_per_segment in segment_runs:\n            # fragment indices relative to the first fragment in this segment_run\n            for i in range(fragments_per_segment):\n                # Compute the fragment index relative to the fragments_run fragments list\n                fragment_index = i\n                if fragment_index < len(fragments_run['fragments']):\n                    fragment = fragments_run['fragments'][fragment_index]\n                    # Append tuple (segment, fragment) as requested\n                    result.append((segment, fragment))\n\n    return result", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    result = []\n    # Each segment corresponds to an entry in segments list.\n    # Each fragments run corresponds to an entry in fragments list.\n    # The fragments_runs list contains one or more fragment runs.\n    # As per read_abst, segments and fragments runs are separate lists.\n    #\n    # The boot_info does not explicitly link segments to fragments,\n    # but from the context, fragments_runs correspond to fragments runs for all segments.\n    #\n    # The data structure from read_asrt()\n    # 'segment_run': [(first_segment, fragments_per_segment), ...]\n    #\n    # Actually boot_info['segments'] is a list of dict with 'segment_run': list of tuples.\n    # Each segment dict like: {'segment_run': [(first_segment, fragments_per_segment), ...]}\n    #\n    # So we need to iterate through each Segment's segment_run entries and\n    # map fragments accordingly.\n    #\n    # For each segment_run entry in segments (segment_run is a list of tuples):\n    # first_segment: starting segment number\n    # fragments_per_segment: number of fragments in that segment\n    #\n    # fragments_runs is a list (from read_abst) of fragment runs,\n    # each fragment run dict has a 'fragments' list (from read_afrt),\n    # each fragment is a dict with keys including 'first' (fragment number), 'ts', 'duration', etc.\n    #\n    # We want to flatten this into a list of (segment, fragment) tuples,\n    # where segment is first_segment + segment index offset,\n    # fragment is the fragment dict from fragments_runs.\n    #\n    # But the official code uses a single segment (elements on boot_info['segments']) and multiple fragment runs;\n    # each fragment run contains fragment dicts.\n    #\n    # We assume a 1:1 mapping of segments to fragment runs by index.\n    #\n    # Because boot_info['segments'] is a list of dicts (each with segment_run list),\n    # and boot_info['fragments'] is list of dicts (each with 'fragments' list),\n    # we can do parallel iteration.\n    #\n    # We'll iterate over segments and fragments_runs by index and build the list.\n\n    for seg_idx, segment in enumerate(segments):\n        segment_runs = segment.get('segment_run', [])\n        # The corresponding fragments run for this segment (assuming matching index)\n        if seg_idx >= len(fragments_runs):\n            break\n        fragments_run = fragments_runs[seg_idx]\n        fragments = fragments_run.get('fragments', [])\n\n        # For each segment run in this segment:\n        # segment_run: list of tuples (first_segment, fragments_per_segment)\n        # The fragments list contains fragments numbered sequentially.\n        # We need to map each fragment to the correct segment,\n        # incrementing segment number as appropriate.\n\n        frag_index = 0\n        for first_segment, fragments_per_segment in segment_runs:\n            for i in range(fragments_per_segment):\n                if frag_index >= len(fragments):\n                    break\n                segment_num = first_segment + i\n                fragment = fragments[frag_index]\n                result.append((segment_num, fragment))\n                frag_index += 1\n\n    return result"], "test": ["from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_groups = boot_info.get('fragments', [])\n    result = []\n    for segment, fragments_group in zip(segments, fragments_groups):\n        # segment_run is a list of (first_segment, fragments_per_segment)\n        segment_run = segment.get('segment_run', [])\n        for (first_segment, fragments_per_segment) in segment_run:\n            # For each segment_run entry, take the corresponding fragments\n            for i in range(fragments_per_segment):\n                fragment_index = first_segment + i - 1  # segments start counting from 1\n                # Check bounds and fetch the fragment from fragments_group\n                if 0 <= fragment_index < len(fragments_group):\n                    fragment = fragments_group[fragment_index]\n                    result.append((segment, fragment))\n    return result\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    result = []\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    for seg_idx, segment in enumerate(segments):\n        # segment_run is list of tuples (first_segment, fragments_per_segment)\n        segment_runs = segment.get('segment_run', [])\n        for fr_idx, fragments_data in enumerate(fragments_runs):\n            # Each fragments_data is a dict with a 'fragments' key (list of fragment dicts)\n            fragments = fragments_data.get('fragments', [])\n\n            # For each segment_run tuple in this segment, find fragments belonging to it.\n            for first_segment, fragments_per_segment in segment_runs:\n                # Select fragments that belong to this segment run\n                # The fragment's 'first' index should be within the segment range:\n                seg_start = first_segment\n                seg_end = first_segment + fragments_per_segment\n                # Collect matching fragments among fragments list (from fragments_data)\n                matched_fragments = [\n                    fragment\n                    for fragment in fragments\n                    if seg_start <= fragment.get('first', 0) < seg_end\n                ]\n                for fragment in matched_fragments:\n                    result.append((segment, fragment))\n\n    return result\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    # segments is a list of dicts with key 'segment_run' which is a list of (first_segment, fragments_per_segment)\n    # fragments_runs is a list of dicts with key 'fragments' which is a list of fragment dicts with 'first' integer\n\n    # We need to map each fragment to a segment.\n    # The segments list is a list of segments where each segment contains a 'segment_run' list of tuples:\n    # (first_segment_number, fragments_per_segment)\n    # The fragments list is a list of fragments runs, each with a 'fragments' list that has fragment dicts with 'first' fields (fragment number).\n\n    # We will enumerate segments and their runs to get segment index and fragment numbering.\n    # The segment_run entries give us the segment number and how many fragments it contains.\n\n    # Create a list indexed by segment number mapping to segment index in segments\n    # Actually, segments is a list of segment dicts; but each segment has multiple runs.\n    # We will combine all segment runs across segments, keeping track of which segment they belong to.\n\n    # For each segments[i] (segment), for each (first_segment, fragments_per_segment) in segment_run:\n    # We'll build a mapping of segment number to (segments index i, run index, first_segment, fragments_per_segment)\n    # Then when iterating fragments, find which segment run they belong to.\n\n    # However, the segments list itself is a list of dicts with 'segment_run' list, so it is a structure for grouping, but\n    # The fragment numbers are aligned globally.\n\n    # We'll construct a sorted list of (segment_number, segment_index, run_index, fragments_per_segment)\n    segment_run_info = []\n    for segment_index, segment in enumerate(segments):\n        for run_index, (first_segment, fragments_per_segment) in enumerate(segment['segment_run']):\n            segment_run_info.append((first_segment, segment_index, run_index, fragments_per_segment))\n\n    # Sort by first_segment\n    segment_run_info.sort(key=lambda x: x[0])\n\n    # Now iterate fragments runs and their fragments with fragment number (first)\n    # For each fragment, find which segment run it belongs to by comparing fragment number with segment_run intervals\n    # We build a list of intervals: each run covers fragment indices from first_segment to first_segment + fragments_per_segment -1\n\n    # We'll use segment_run_info and map fragment numbers to segment runs\n    # If no segment run is found, assign None\n\n    for fragments_run_index, fragments_run in enumerate(fragments_runs):\n        for fragment in fragments_run['fragments']:\n            fragment_number = fragment['first']\n\n            # Find segment run for this fragment_number\n            seg_index = None\n            run_index = None\n            for (first_segment, segment_index, run_idx, fragments_per_segment) in segment_run_info:\n                if first_segment <= fragment_number < first_segment + fragments_per_segment:\n                    seg_index = segment_index\n                    run_index = run_idx\n                    break\n\n            segment = segments[seg_index] if seg_index is not None else None\n            fragments_list.append((segment, fragment))\n\n    return fragments_list\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    result = []\n\n    for segment, fragments_run in zip(segments, fragments_runs):\n        # Each segment contains 'segment_run' list of tuples (first_segment, fragments_per_segment)\n        segment_runs = segment.get('segment_run', [])\n        \n        for first_segment, fragments_per_segment in segment_runs:\n            # fragment indices relative to the first fragment in this segment_run\n            for i in range(fragments_per_segment):\n                # Compute the fragment index relative to the fragments_run fragments list\n                fragment_index = i\n                if fragment_index < len(fragments_run['fragments']):\n                    fragment = fragments_run['fragments'][fragment_index]\n                    # Append tuple (segment, fragment) as requested\n                    result.append((segment, fragment))\n\n    return result\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    result = []\n    # Each segment corresponds to an entry in segments list.\n    # Each fragments run corresponds to an entry in fragments list.\n    # The fragments_runs list contains one or more fragment runs.\n    # As per read_abst, segments and fragments runs are separate lists.\n    #\n    # The boot_info does not explicitly link segments to fragments,\n    # but from the context, fragments_runs correspond to fragments runs for all segments.\n    #\n    # The data structure from read_asrt()\n    # 'segment_run': [(first_segment, fragments_per_segment), ...]\n    #\n    # Actually boot_info['segments'] is a list of dict with 'segment_run': list of tuples.\n    # Each segment dict like: {'segment_run': [(first_segment, fragments_per_segment), ...]}\n    #\n    # So we need to iterate through each Segment's segment_run entries and\n    # map fragments accordingly.\n    #\n    # For each segment_run entry in segments (segment_run is a list of tuples):\n    # first_segment: starting segment number\n    # fragments_per_segment: number of fragments in that segment\n    #\n    # fragments_runs is a list (from read_abst) of fragment runs,\n    # each fragment run dict has a 'fragments' list (from read_afrt),\n    # each fragment is a dict with keys including 'first' (fragment number), 'ts', 'duration', etc.\n    #\n    # We want to flatten this into a list of (segment, fragment) tuples,\n    # where segment is first_segment + segment index offset,\n    # fragment is the fragment dict from fragments_runs.\n    #\n    # But the official code uses a single segment (elements on boot_info['segments']) and multiple fragment runs;\n    # each fragment run contains fragment dicts.\n    #\n    # We assume a 1:1 mapping of segments to fragment runs by index.\n    #\n    # Because boot_info['segments'] is a list of dicts (each with segment_run list),\n    # and boot_info['fragments'] is list of dicts (each with 'fragments' list),\n    # we can do parallel iteration.\n    #\n    # We'll iterate over segments and fragments_runs by index and build the list.\n\n    for seg_idx, segment in enumerate(segments):\n        segment_runs = segment.get('segment_run', [])\n        # The corresponding fragments run for this segment (assuming matching index)\n        if seg_idx >= len(fragments_runs):\n            break\n        fragments_run = fragments_runs[seg_idx]\n        fragments = fragments_run.get('fragments', [])\n\n        # For each segment run in this segment:\n        # segment_run: list of tuples (first_segment, fragments_per_segment)\n        # The fragments list contains fragments numbered sequentially.\n        # We need to map each fragment to the correct segment,\n        # incrementing segment number as appropriate.\n\n        frag_index = 0\n        for first_segment, fragments_per_segment in segment_runs:\n            for i in range(fragments_per_segment):\n                if frag_index >= len(fragments):\n                    break\n                segment_num = first_segment + i\n                fragment = fragments[frag_index]\n                result.append((segment_num, fragment))\n                frag_index += 1\n\n    return result\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n"]}
