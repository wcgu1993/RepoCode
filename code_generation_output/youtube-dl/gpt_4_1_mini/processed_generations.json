{"task_id": 146, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from math import ceil\nfrom .aes import aes_decrypt, key_expansion\nfrom .utils import xor\nfrom .compat import compat_b64decode\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # If last block might be incomplete, pad it for aes_decrypt to avoid errors\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR decrypted block with previous ciphertext block (or IV for first block)\n        plaintext_block = xor(decrypted_block, previous_cipher_block)\n\n        decrypted_data += plaintext_block\n        previous_cipher_block = block\n\n    # Remove PKCS#7 padding from the decrypted data\n    if decrypted_data:\n        padding_len = decrypted_data[-1]\n        if 1 <= padding_len <= BLOCK_SIZE_BYTES:\n            # Verify padding validity\n            if decrypted_data[-padding_len:] == [padding_len] * padding_len:\n                decrypted_data = decrypted_data[:-padding_len]\n\n    return decrypted_data", "from math import ceil\nfrom .aes import key_expansion, aes_decrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Decrypt the current block\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR with the previous ciphertext block (or IV for first block)\n        plain_block = xor(decrypted_block, previous_cipher_block)\n        decrypted_data += plain_block\n        previous_cipher_block = block\n\n    decrypted_data = decrypted_data[:len(data)]\n    return decrypted_data", "from math import ceil\nfrom youtube_dl.aes import key_expansion, aes_decrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Decrypt current block\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR with previous cipher block (or IV for first block) to get plaintext block\n        plaintext_block = xor(decrypted_block, previous_cipher_block)\n        decrypted_data += plaintext_block\n        # Update previous cipher block to current ciphertext block\n        previous_cipher_block = block\n\n    # Remove PKCS#7 padding\n    if not decrypted_data:\n        return decrypted_data\n    padding_len = decrypted_data[-1]\n    if padding_len < 1 or padding_len > BLOCK_SIZE_BYTES:\n        # Invalid padding, return full decrypted_data\n        return decrypted_data\n    if decrypted_data[-padding_len:] != [padding_len] * padding_len:\n        # Invalid padding, return full decrypted_data\n        return decrypted_data\n\n    return decrypted_data[:-padding_len]", "from math import ceil\nfrom youtube_dl.aes import key_expansion, aes_decrypt, xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Decrypt current block\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR with previous cipher block (or IV for first block)\n        plain_block = xor(decrypted_block, previous_block)\n        decrypted_data += plain_block\n        # Current cipher block becomes previous for next iteration\n        previous_block = block\n\n    # Remove PKCS#7 padding if present\n    if decrypted_data:\n        padding_len = decrypted_data[-1]\n        if 1 <= padding_len <= BLOCK_SIZE_BYTES and all(\n            decrypted_data[-i] == padding_len for i in range(1, padding_len + 1)\n        ):\n            decrypted_data = decrypted_data[:-padding_len]\n\n    return decrypted_data", "from math import ceil\n\nfrom youtube_dl.aes import key_expansion, aes_decrypt, xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # If block less than 16 bytes (shouldn't normally happen), pad with zeros to decrypt safely\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        plain_block = xor(decrypted_block, previous_cipher_block)\n\n        decrypted_data += plain_block\n        previous_cipher_block = block\n\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\nfrom .aes import aes_decrypt, key_expansion\nfrom .utils import xor\nfrom .compat import compat_b64decode\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # If last block might be incomplete, pad it for aes_decrypt to avoid errors\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR decrypted block with previous ciphertext block (or IV for first block)\n        plaintext_block = xor(decrypted_block, previous_cipher_block)\n\n        decrypted_data += plaintext_block\n        previous_cipher_block = block\n\n    # Remove PKCS#7 padding from the decrypted data\n    if decrypted_data:\n        padding_len = decrypted_data[-1]\n        if 1 <= padding_len <= BLOCK_SIZE_BYTES:\n            # Verify padding validity\n            if decrypted_data[-padding_len:] == [padding_len] * padding_len:\n                decrypted_data = decrypted_data[:-padding_len]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\nfrom .aes import key_expansion, aes_decrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Decrypt the current block\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR with the previous ciphertext block (or IV for first block)\n        plain_block = xor(decrypted_block, previous_cipher_block)\n        decrypted_data += plain_block\n        previous_cipher_block = block\n\n    decrypted_data = decrypted_data[:len(data)]\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import key_expansion, aes_decrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Decrypt current block\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR with previous cipher block (or IV for first block) to get plaintext block\n        plaintext_block = xor(decrypted_block, previous_cipher_block)\n        decrypted_data += plaintext_block\n        # Update previous cipher block to current ciphertext block\n        previous_cipher_block = block\n\n    # Remove PKCS#7 padding\n    if not decrypted_data:\n        return decrypted_data\n    padding_len = decrypted_data[-1]\n    if padding_len < 1 or padding_len > BLOCK_SIZE_BYTES:\n        # Invalid padding, return full decrypted_data\n        return decrypted_data\n    if decrypted_data[-padding_len:] != [padding_len] * padding_len:\n        # Invalid padding, return full decrypted_data\n        return decrypted_data\n\n    return decrypted_data[:-padding_len]\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import key_expansion, aes_decrypt, xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Decrypt current block\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR with previous cipher block (or IV for first block)\n        plain_block = xor(decrypted_block, previous_block)\n        decrypted_data += plain_block\n        # Current cipher block becomes previous for next iteration\n        previous_block = block\n\n    # Remove PKCS#7 padding if present\n    if decrypted_data:\n        padding_len = decrypted_data[-1]\n        if 1 <= padding_len <= BLOCK_SIZE_BYTES and all(\n            decrypted_data[-i] == padding_len for i in range(1, padding_len + 1)\n        ):\n            decrypted_data = decrypted_data[:-padding_len]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\n\nfrom youtube_dl.aes import key_expansion, aes_decrypt, xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # If block less than 16 bytes (shouldn't normally happen), pad with zeros to decrypt safely\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        plain_block = xor(decrypted_block, previous_cipher_block)\n\n        decrypted_data += plain_block\n        previous_cipher_block = block\n\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n"]}
{"task_id": 147, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding: Add N bytes each of value N, where N is the number of padding bytes needed\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [pad_len] * pad_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(padded_data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        xor_block = xor(block, previous_cipher_block)\n\n        cipher_block = aes_encrypt(xor_block, expanded_key)\n\n        encrypted_data += cipher_block\n        previous_cipher_block = cipher_block\n\n    return encrypted_data", "from math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [pad_len] * pad_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR with previous ciphertext block (or IV for first block)\n        xored_block = xor(block, previous_cipher_block)\n        # Encrypt the xored block\n        cipher_block = aes_encrypt(xored_block, expanded_key)\n        encrypted_data += cipher_block\n        previous_cipher_block = cipher_block\n\n    return encrypted_data", "from math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # Apply PKCS#7 padding\n    padding_length = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padded_data = data[:] + [padding_length] * padding_length\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(padded_data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR with previous ciphertext block (or IV for first)\n        block = xor(block, previous_cipher_block)\n        # Encrypt the block\n        cipher_block = aes_encrypt(block, expanded_key)\n        encrypted_data += cipher_block\n        previous_cipher_block = cipher_block\n\n    return encrypted_data", "from math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [padding_len] * padding_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(padded_data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv[:]\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR plaintext block with previous cipher block (or IV for the first block)\n        xored_block = xor(block, previous_cipher_block)\n        # Encrypt the xored_block\n        cipher_block = aes_encrypt(xored_block, expanded_key)\n        encrypted_data += cipher_block\n        previous_cipher_block = cipher_block\n\n    return encrypted_data", "from math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding: add N bytes of value N to fill block size\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padded_data = data[:] + [pad_len] * pad_len\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES : (i + 1) * BLOCK_SIZE_BYTES]\n        block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(block, expanded_key)\n        encrypted_data += encrypted_block\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding: Add N bytes each of value N, where N is the number of padding bytes needed\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [pad_len] * pad_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(padded_data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        xor_block = xor(block, previous_cipher_block)\n\n        cipher_block = aes_encrypt(xor_block, expanded_key)\n\n        encrypted_data += cipher_block\n        previous_cipher_block = cipher_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [pad_len] * pad_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR with previous ciphertext block (or IV for first block)\n        xored_block = xor(block, previous_cipher_block)\n        # Encrypt the xored block\n        cipher_block = aes_encrypt(xored_block, expanded_key)\n        encrypted_data += cipher_block\n        previous_cipher_block = cipher_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # Apply PKCS#7 padding\n    padding_length = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padded_data = data[:] + [padding_length] * padding_length\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(padded_data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR with previous ciphertext block (or IV for first)\n        block = xor(block, previous_cipher_block)\n        # Encrypt the block\n        cipher_block = aes_encrypt(block, expanded_key)\n        encrypted_data += cipher_block\n        previous_cipher_block = cipher_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [padding_len] * padding_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(padded_data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv[:]\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR plaintext block with previous cipher block (or IV for the first block)\n        xored_block = xor(block, previous_cipher_block)\n        # Encrypt the xored_block\n        cipher_block = aes_encrypt(xored_block, expanded_key)\n        encrypted_data += cipher_block\n        previous_cipher_block = cipher_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding: add N bytes of value N to fill block size\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padded_data = data[:] + [pad_len] * pad_len\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES : (i + 1) * BLOCK_SIZE_BYTES]\n        block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(block, expanded_key)\n        encrypted_data += encrypted_block\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n"]}
{"task_id": 148, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from youtube_dl.aes import key_schedule_core\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    expanded_key = list(data)\n    key_size = len(data)  # 16, 24, or 32 bytes\n    if key_size not in {16, 24, 32}:\n        raise ValueError(\"Invalid key size: must be 16, 24, or 32 bytes\")\n\n    # Number of 4-byte words in the key\n    Nk = key_size // 4\n    # Number of 4-byte words in the expanded key\n    # AES standard rounds + 1 * 4 words, so:\n    # 16 bytes -> 44 words (176 bytes)\n    # 24 bytes -> 52 words (208 bytes)\n    # 32 bytes -> 60 words (240 bytes)\n    Nb = 4\n    Nr = {16: 10, 24: 12, 32: 14}[key_size]\n    expanded_key_words = Nk * [0]  # Will grow dynamically, this is only initial length\n\n    # Convert expanded_key list to words (4 bytes each) for processing\n    # We'll store expanded keys as words (lists of 4 ints)\n    key_words = [expanded_key[i * 4:(i + 1) * 4] for i in range(Nk)]\n    expanded_words = key_words.copy()\n\n    i = Nk\n    while len(expanded_words) < Nb * (Nr + 1):\n        temp = expanded_words[-1].copy()\n\n        if i % Nk == 0:\n            temp = key_schedule_core(temp, i // Nk - 1)\n        elif Nk > 6 and i % Nk == 4:\n            # For 256-bit key, extra sub_bytes step at i mod Nk == 4\n            from youtube_dl.aes import sub_bytes\n            temp = sub_bytes(temp)\n\n        # XOR with word Nk positions before\n        prev_word = expanded_words[i - Nk]\n        new_word = [x ^ y for x, y in zip(prev_word, temp)]\n\n        expanded_words.append(new_word)\n        i += 1\n\n    # Flatten expanded_words back to a list of ints\n    expanded_key = []\n    for word in expanded_words:\n        expanded_key.extend(word)\n\n    return expanded_key", "from youtube_dl.aes import key_schedule_core\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_size = len(data)\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Key length must be 16, 24 or 32 bytes\")\n\n    # Number of 32-bit words in the original key\n    Nk = key_size // 4\n    # Number of rounds depending on key size\n    Nr = {4: 10, 6: 12, 8: 14}[Nk]\n    # Total number of 32-bit words in expanded key\n    total_words = 4 * (Nr + 1)\n\n    # The expanded key will be a list of bytes\n    expanded_key = list(data)\n\n    rcon_iteration = 1\n\n    while len(expanded_key) < total_words * 4:\n        # Get the last 4 bytes (a word) from the current expanded key\n        temp = expanded_key[-4:]\n\n        # Every Nk words, apply the core key schedule function\n        if len(expanded_key) // 4 % Nk == 0:\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        # For 256-bit keys, also apply sub_bytes to the word every 4th word (except words multiple of Nk)\n        elif Nk == 8 and len(expanded_key) // 4 % Nk == 4:\n            # sub_bytes is applied on temp here\n            # Since key_schedule_core imports sub_bytes internally, we need to replicate sub_bytes usage\n            # But sub_bytes is not provided in context functions or file content.\n            # To avoid that, we trust the instructions only to use key_schedule_core and xor given.\n            # Here, code usually would call sub_bytes on temp, but since unavailable, leave as is.\n            # But from AES spec, for Nk=8 keys: every 4th word applies sub_bytes without rotation or RCON xor.\n            # We will implement sub_bytes here inline:\n            # Since sub_bytes is not provided, and neither S-box, we cannot perform it.\n            # Hence this part cannot be implemented exactly as in AES spec.\n            # The safest way is to skip this step or raise NotImplementedError.\n            # However, according to instructions, we only have key_schedule_core from context functions.\n            # So we will implement a local sub_bytes here using standard AES S-box from pycryptodome.\n\n            # Import here\n            from Cryptodome.Cipher import AES\n            # Unfortunately AES.sbox is not exposed in pycryptodome. We must define S_box manually.\n\n            S_BOX = (\n                0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n                0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n                0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n                0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n                0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n                0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n                0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n                0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n                0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n                0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n                0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n                0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n                0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n                0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n                0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n                0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n                0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n                0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n                0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n                0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n                0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n                0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n                0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n                0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n                0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n                0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n                0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n                0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n                0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n                0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n                0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n                0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n            )\n            temp = [S_BOX[b] for b in temp]\n\n        # XOR temp with the word Nk positions before and append to the expanded key\n        prev_word = expanded_key[-4 * Nk: -4 * Nk + 4]\n        expanded_word = [a ^ b for a, b in zip(temp, prev_word)]\n        expanded_key.extend(expanded_word)\n\n    return expanded_key", "from youtube_dl.aes import key_schedule_core\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Determine key length and expanded key length\n    key_length = len(data)  # 16, 24 or 32\n    if key_length == 16:\n        expanded_key_length = 176\n        nk = 4  # number of 32-bit words in the key\n        nr = 10 # number of rounds\n    elif key_length == 24:\n        expanded_key_length = 208\n        nk = 6\n        nr = 12\n    elif key_length == 32:\n        expanded_key_length = 240\n        nk = 8\n        nr = 14\n    else:\n        raise ValueError(\"Invalid key size: must be 16, 24 or 32 bytes\")\n\n    # Initialize expanded key with original key data\n    expanded_key = list(data)\n\n    rcon_iteration = 1\n    i = nk\n    # Expand until we fill the expanded key to desired length\n    while len(expanded_key) < expanded_key_length:\n        # Get previous 4 bytes (one word)\n        temp = expanded_key[-4:]\n\n        if i % nk == 0:\n            # Apply core schedule function (rotate, sub, RCON XOR)\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        elif nk > 6 and i % nk == 4:\n            # For 256-bit keys, apply sub_bytes to temp when i mod nk == 4\n            temp = sub_bytes(temp)\n\n        # XOR temp with the word nk positions before\n        word_start = (i - nk) * 4\n        word = expanded_key[word_start: word_start + 4]\n        xored = [a ^ b for a, b in zip(word, temp)]\n        expanded_key += xored\n\n        i += 1\n\n    return expanded_key\n\n\n# sub_bytes function is needed for key_expansion in the nk>6 case\n# Since it is used in key_schedule_core and known in the codebase,\n# we define it here according to AES spec (using AES S-box):\n\nS_BOX = [\n    # 0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,  #0\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,  #1\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,  #2\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,  #3\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,  #4\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,  #5\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,  #6\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,  #7\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,  #8\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,  #9\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,  #A\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,  #B\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,  #C\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,  #D\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,  #E\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16   #F\n]\n\n\ndef sub_bytes(data):\n    \"\"\"\n    Substitute bytes using AES S-box\n\n    @param {int[]} data 4-byte list\n    @returns {int[]} substituted bytes list\n    \"\"\"\n    return [S_BOX[b] for b in data]", "from youtube_dl.aes import key_schedule_core\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Determine key length and number of rounds based on AES specs\n    key_len = len(data)\n    if key_len == 16:\n        # AES-128: 10 rounds + initial key => 11 * 16 = 176 bytes expanded key\n        expanded_key_size = 176\n        rounds = 10\n    elif key_len == 24:\n        # AES-192: 12 rounds + initial key => 13 * 16 = 208 bytes\n        expanded_key_size = 208\n        rounds = 12\n    elif key_len == 32:\n        # AES-256: 14 rounds + initial key => 15 * 16 = 240 bytes\n        expanded_key_size = 240\n        rounds = 14\n    else:\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    expanded_key = data[:]\n    rcon_iteration = 1\n    bytes_generated = key_len\n\n    # The expanded key is generated 4 bytes at a time\n    # The iteration step in key_schedule_core operates on 4-byte words\n    # Each round adds 16 bytes (4 words)\n    while bytes_generated < expanded_key_size:\n        # Last 4 bytes of the current expanded key\n        temp = expanded_key[-4:]\n\n        # Every key_len bytes, apply core transformation\n        if bytes_generated % key_len == 0:\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        # For AES-256, extra substitution every 32 bytes but not at key_len step\n        elif key_len == 32 and (bytes_generated % key_len) == 16:\n            # Apply sub_bytes only (no rotation or RCON)\n            from youtube_dl.aes import sub_bytes  # import here to avoid global import\n            temp = sub_bytes(temp)\n\n        # XOR with the 4 bytes key_len bytes before the current position\n        for i in range(4):\n            byte = expanded_key[bytes_generated - key_len + i] ^ temp[i]\n            expanded_key.append(byte)\n\n        bytes_generated += 4\n\n    return expanded_key", "from youtube_dl.aes import key_schedule_core\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_len = len(data)\n    if key_len not in (16, 24, 32):\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    # Number of 4-byte words comprising the key\n    Nk = key_len // 4\n    # Number of rounds + 1 (depending on key length)\n    Nr = {4: 10, 6: 12, 8: 14}[Nk]\n    # Number of words in the expanded key\n    Nb = 4\n    expanded_key_words = Nb * (Nr + 1)  # total 4-byte words in expanded key\n\n    # Expanded key as list of ints (bytes)\n    expanded_key = list(data)\n\n    rcon_iteration = 1  # Rcon round iteration index\n\n    while len(expanded_key) < expanded_key_words * 4:\n        # Last 4 bytes of currently expanded key\n        temp = expanded_key[-4:]\n\n        if (len(expanded_key) // 4) % Nk == 0:\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        elif Nk > 6 and (len(expanded_key) // 4) % Nk == 4:\n            # For 256-bit key, apply sub_bytes to temp\n            from youtube_dl.aes import sub_bytes\n            temp = sub_bytes(temp)\n\n        # XOR temp with word Nk positions before\n        word_before = expanded_key[-Nk * 4 : -Nk * 4 + 4]\n        temp = [x ^ y for x, y in zip(temp, word_before)]\n\n        expanded_key.extend(temp)\n\n    return expanded_key"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\nfrom youtube_dl.aes import key_schedule_core\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    expanded_key = list(data)\n    key_size = len(data)  # 16, 24, or 32 bytes\n    if key_size not in {16, 24, 32}:\n        raise ValueError(\"Invalid key size: must be 16, 24, or 32 bytes\")\n\n    # Number of 4-byte words in the key\n    Nk = key_size // 4\n    # Number of 4-byte words in the expanded key\n    # AES standard rounds + 1 * 4 words, so:\n    # 16 bytes -> 44 words (176 bytes)\n    # 24 bytes -> 52 words (208 bytes)\n    # 32 bytes -> 60 words (240 bytes)\n    Nb = 4\n    Nr = {16: 10, 24: 12, 32: 14}[key_size]\n    expanded_key_words = Nk * [0]  # Will grow dynamically, this is only initial length\n\n    # Convert expanded_key list to words (4 bytes each) for processing\n    # We'll store expanded keys as words (lists of 4 ints)\n    key_words = [expanded_key[i * 4:(i + 1) * 4] for i in range(Nk)]\n    expanded_words = key_words.copy()\n\n    i = Nk\n    while len(expanded_words) < Nb * (Nr + 1):\n        temp = expanded_words[-1].copy()\n\n        if i % Nk == 0:\n            temp = key_schedule_core(temp, i // Nk - 1)\n        elif Nk > 6 and i % Nk == 4:\n            # For 256-bit key, extra sub_bytes step at i mod Nk == 4\n            from youtube_dl.aes import sub_bytes\n            temp = sub_bytes(temp)\n\n        # XOR with word Nk positions before\n        prev_word = expanded_words[i - Nk]\n        new_word = [x ^ y for x, y in zip(prev_word, temp)]\n\n        expanded_words.append(new_word)\n        i += 1\n\n    # Flatten expanded_words back to a list of ints\n    expanded_key = []\n    for word in expanded_words:\n        expanded_key.extend(word)\n\n    return expanded_key\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\nfrom youtube_dl.aes import key_schedule_core\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_size = len(data)\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Key length must be 16, 24 or 32 bytes\")\n\n    # Number of 32-bit words in the original key\n    Nk = key_size // 4\n    # Number of rounds depending on key size\n    Nr = {4: 10, 6: 12, 8: 14}[Nk]\n    # Total number of 32-bit words in expanded key\n    total_words = 4 * (Nr + 1)\n\n    # The expanded key will be a list of bytes\n    expanded_key = list(data)\n\n    rcon_iteration = 1\n\n    while len(expanded_key) < total_words * 4:\n        # Get the last 4 bytes (a word) from the current expanded key\n        temp = expanded_key[-4:]\n\n        # Every Nk words, apply the core key schedule function\n        if len(expanded_key) // 4 % Nk == 0:\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        # For 256-bit keys, also apply sub_bytes to the word every 4th word (except words multiple of Nk)\n        elif Nk == 8 and len(expanded_key) // 4 % Nk == 4:\n            # sub_bytes is applied on temp here\n            # Since key_schedule_core imports sub_bytes internally, we need to replicate sub_bytes usage\n            # But sub_bytes is not provided in context functions or file content.\n            # To avoid that, we trust the instructions only to use key_schedule_core and xor given.\n            # Here, code usually would call sub_bytes on temp, but since unavailable, leave as is.\n            # But from AES spec, for Nk=8 keys: every 4th word applies sub_bytes without rotation or RCON xor.\n            # We will implement sub_bytes here inline:\n            # Since sub_bytes is not provided, and neither S-box, we cannot perform it.\n            # Hence this part cannot be implemented exactly as in AES spec.\n            # The safest way is to skip this step or raise NotImplementedError.\n            # However, according to instructions, we only have key_schedule_core from context functions.\n            # So we will implement a local sub_bytes here using standard AES S-box from pycryptodome.\n\n            # Import here\n            from Cryptodome.Cipher import AES\n            # Unfortunately AES.sbox is not exposed in pycryptodome. We must define S_box manually.\n\n            S_BOX = (\n                0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n                0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n                0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n                0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n                0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n                0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n                0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n                0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n                0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n                0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n                0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n                0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n                0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n                0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n                0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n                0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n                0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n                0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n                0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n                0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n                0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n                0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n                0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n                0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n                0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n                0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n                0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n                0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n                0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n                0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n                0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n                0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n            )\n            temp = [S_BOX[b] for b in temp]\n\n        # XOR temp with the word Nk positions before and append to the expanded key\n        prev_word = expanded_key[-4 * Nk: -4 * Nk + 4]\n        expanded_word = [a ^ b for a, b in zip(temp, prev_word)]\n        expanded_key.extend(expanded_word)\n\n    return expanded_key\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\nfrom youtube_dl.aes import key_schedule_core\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Determine key length and expanded key length\n    key_length = len(data)  # 16, 24 or 32\n    if key_length == 16:\n        expanded_key_length = 176\n        nk = 4  # number of 32-bit words in the key\n        nr = 10 # number of rounds\n    elif key_length == 24:\n        expanded_key_length = 208\n        nk = 6\n        nr = 12\n    elif key_length == 32:\n        expanded_key_length = 240\n        nk = 8\n        nr = 14\n    else:\n        raise ValueError(\"Invalid key size: must be 16, 24 or 32 bytes\")\n\n    # Initialize expanded key with original key data\n    expanded_key = list(data)\n\n    rcon_iteration = 1\n    i = nk\n    # Expand until we fill the expanded key to desired length\n    while len(expanded_key) < expanded_key_length:\n        # Get previous 4 bytes (one word)\n        temp = expanded_key[-4:]\n\n        if i % nk == 0:\n            # Apply core schedule function (rotate, sub, RCON XOR)\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        elif nk > 6 and i % nk == 4:\n            # For 256-bit keys, apply sub_bytes to temp when i mod nk == 4\n            temp = sub_bytes(temp)\n\n        # XOR temp with the word nk positions before\n        word_start = (i - nk) * 4\n        word = expanded_key[word_start: word_start + 4]\n        xored = [a ^ b for a, b in zip(word, temp)]\n        expanded_key += xored\n\n        i += 1\n\n    return expanded_key\n\n\n# sub_bytes function is needed for key_expansion in the nk>6 case\n# Since it is used in key_schedule_core and known in the codebase,\n# we define it here according to AES spec (using AES S-box):\n\nS_BOX = [\n    # 0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,  #0\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,  #1\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,  #2\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,  #3\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,  #4\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,  #5\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,  #6\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,  #7\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,  #8\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,  #9\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,  #A\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,  #B\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,  #C\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,  #D\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,  #E\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16   #F\n]\n\n\ndef sub_bytes(data):\n    \"\"\"\n    Substitute bytes using AES S-box\n\n    @param {int[]} data 4-byte list\n    @returns {int[]} substituted bytes list\n    \"\"\"\n    return [S_BOX[b] for b in data]\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\nfrom youtube_dl.aes import key_schedule_core\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Determine key length and number of rounds based on AES specs\n    key_len = len(data)\n    if key_len == 16:\n        # AES-128: 10 rounds + initial key => 11 * 16 = 176 bytes expanded key\n        expanded_key_size = 176\n        rounds = 10\n    elif key_len == 24:\n        # AES-192: 12 rounds + initial key => 13 * 16 = 208 bytes\n        expanded_key_size = 208\n        rounds = 12\n    elif key_len == 32:\n        # AES-256: 14 rounds + initial key => 15 * 16 = 240 bytes\n        expanded_key_size = 240\n        rounds = 14\n    else:\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    expanded_key = data[:]\n    rcon_iteration = 1\n    bytes_generated = key_len\n\n    # The expanded key is generated 4 bytes at a time\n    # The iteration step in key_schedule_core operates on 4-byte words\n    # Each round adds 16 bytes (4 words)\n    while bytes_generated < expanded_key_size:\n        # Last 4 bytes of the current expanded key\n        temp = expanded_key[-4:]\n\n        # Every key_len bytes, apply core transformation\n        if bytes_generated % key_len == 0:\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        # For AES-256, extra substitution every 32 bytes but not at key_len step\n        elif key_len == 32 and (bytes_generated % key_len) == 16:\n            # Apply sub_bytes only (no rotation or RCON)\n            from youtube_dl.aes import sub_bytes  # import here to avoid global import\n            temp = sub_bytes(temp)\n\n        # XOR with the 4 bytes key_len bytes before the current position\n        for i in range(4):\n            byte = expanded_key[bytes_generated - key_len + i] ^ temp[i]\n            expanded_key.append(byte)\n\n        bytes_generated += 4\n\n    return expanded_key\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\nfrom youtube_dl.aes import key_schedule_core\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_len = len(data)\n    if key_len not in (16, 24, 32):\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    # Number of 4-byte words comprising the key\n    Nk = key_len // 4\n    # Number of rounds + 1 (depending on key length)\n    Nr = {4: 10, 6: 12, 8: 14}[Nk]\n    # Number of words in the expanded key\n    Nb = 4\n    expanded_key_words = Nb * (Nr + 1)  # total 4-byte words in expanded key\n\n    # Expanded key as list of ints (bytes)\n    expanded_key = list(data)\n\n    rcon_iteration = 1  # Rcon round iteration index\n\n    while len(expanded_key) < expanded_key_words * 4:\n        # Last 4 bytes of currently expanded key\n        temp = expanded_key[-4:]\n\n        if (len(expanded_key) // 4) % Nk == 0:\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        elif Nk > 6 and (len(expanded_key) // 4) % Nk == 4:\n            # For 256-bit key, apply sub_bytes to temp\n            from youtube_dl.aes import sub_bytes\n            temp = sub_bytes(temp)\n\n        # XOR temp with word Nk positions before\n        word_before = expanded_key[-Nk * 4 : -Nk * 4 + 4]\n        temp = [x ^ y for x, y in zip(temp, word_before)]\n\n        expanded_key.extend(temp)\n\n    return expanded_key\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n"]}
{"task_id": 149, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from youtube_dl.aes import mix_columns\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on key size (expanded key length)\n    # 16-byte key -> 10 rounds, 24-byte key -> 12 rounds, 32-byte key -> 14 rounds\n    # expanded_key length is 176, 208 or 240 bytes respectively\n    Nr = (len(expanded_key) // 16) - 1\n\n    # Copy input data to state (list of 16 ints)\n    state = data[:]\n\n    # AddRoundKey - initial round key addition\n    for i in range(16):\n        state[i] ^= expanded_key[i]\n\n    # For rounds 1 to Nr-1 do the main rounds\n    for round_idx in range(1, Nr):\n        # SubBytes (using sub_bytes on state)\n        state = sub_bytes(state)\n\n        # ShiftRows (using shift_rows on state)\n        state = shift_rows(state)\n\n        # MixColumns\n        state = mix_columns(state)\n\n        # AddRoundKey\n        round_key_start = round_idx * 16\n        for i in range(16):\n            state[i] ^= expanded_key[round_key_start + i]\n\n    # Final round (Nr-th round) without MixColumns\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = Nr * 16\n    for i in range(16):\n        state[i] ^= expanded_key[round_key_start + i]\n\n    return state\n\n\n# The sub_bytes and shift_rows functions are needed here.\n# They should be defined or imported accordingly.\n# Since only aes_encrypt is requested and no imports from file content,\n# we provide implementations for sub_bytes and shift_rows below:\n\nS_BOX = [\n    # 256-element AES S-box\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]\n\n\ndef sub_bytes(state):\n    \"\"\"Apply the AES S-box substitution to each byte of the state.\"\"\"\n    return [S_BOX[b] for b in state]\n\n\ndef shift_rows(state):\n    \"\"\"\n    Shift rows in the AES state.\n    The state array is indexed as a 4x4 matrix in column-major order:\n    state = [s0, s1, s2, s3, ..., s15]\n    where columns (each of 4 bytes) are contiguous every 4 bytes:\n    index = row + 4 * column\n    Shift rows:\n     - row 0: no shift\n     - row 1: shift left by 1\n     - row 2: shift left by 2\n     - row 3: shift left by 3\n    \"\"\"\n    # Convert to 4x4 matrix (row-major for ease)\n    matrix = [[0]*4 for _ in range(4)]  # matrix[row][col]\n\n    for i in range(16):\n        row = i % 4\n        col = i // 4\n        matrix[row][col] = state[i]\n\n    # Shift rows\n    for r in range(1, 4):\n        matrix[r] = matrix[r][r:] + matrix[r][:r]\n\n    # Convert back to state (column-major)\n    new_state = [0]*16\n    for r in range(4):\n        for c in range(4):\n            new_state[c*4 + r] = matrix[r][c]\n\n    return new_state", "from youtube_dl.aes import mix_columns\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of 32-bit words comprising the cipher key\n    key_len = len(expanded_key)\n    if key_len == 176:  # 16 bytes key => 10 rounds + 1 initial key addition\n        rounds = 10\n    elif key_len == 208:  # 24 bytes key => 12 rounds + 1 initial key addition\n        rounds = 12\n    elif key_len == 240:  # 32 bytes key => 14 rounds + 1 initial key addition\n        rounds = 14\n    else:\n        raise ValueError(\"Invalid expanded_key length\")\n\n    state = data[:]\n\n    # Initial AddRoundKey\n    for i in range(16):\n        state[i] ^= expanded_key[i]\n\n    # Each round is 16 bytes = 4 words\n    # Helper to get the key slice for a round\n    def round_key(r):\n        start = 16 * r\n        return expanded_key[start:start + 16]\n\n    for r in range(1, rounds):\n        # SubBytes\n        state = sub_bytes(state)\n\n        # ShiftRows\n        state = shift_rows(state)\n\n        # MixColumns\n        state = mix_columns(state)\n\n        # AddRoundKey\n        rk = round_key(r)\n        for i in range(16):\n            state[i] ^= rk[i]\n\n    # Last round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    rk = round_key(rounds)\n    for i in range(16):\n        state[i] ^= rk[i]\n\n    return state\n\n\n# Helper functions needed for aes_encrypt (based on AES standard and typical implementations)\n# These are not provided in the context, but are essential.\n# Implementations follow the typical AES specification.\n\n\n# The S-box used by AES (256 values)\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]\n\n\ndef sub_bytes(state):\n    \"\"\"Substitute each byte in the state using the AES S-box\"\"\"\n    return [SBOX[b] for b in state]\n\n\ndef shift_rows(state):\n    \"\"\"Shift rows for AES state; input/output are 16-byte lists\"\"\"\n    # State is in row-major order: state[row + 4 * col]\n    # ShiftRows shifts bytes at rows:\n    # Row 0: no shift\n    # Row 1: shift left by 1\n    # Row 2: shift left by 2\n    # Row 3: shift left by 3\n\n    # Convert to 4x4 matrix (row-major)\n    matrix = [state[i*4:(i+1)*4] for i in range(4)]\n\n    for r in range(1, 4):\n        matrix[r] = matrix[r][r:] + matrix[r][:r]\n\n    # Flatten back to list\n    return [matrix[i][j] for i in range(4) for j in range(4)]", "from youtube_dl.aes import mix_columns\n\n\n# S-box for SubBytes step\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]\n\n# RCON for AddRoundKey in Key Expansion, not needed here but included for completeness\n\ndef sub_bytes(state):\n    \"\"\"\n    Perform SubBytes step of AES:\n    Substitute each byte in state using the SBOX.\n    \"\"\"\n    return [SBOX[b] for b in state]\n\ndef shift_rows(state):\n    \"\"\"\n    Perform ShiftRows step of AES on a 16-byte state (list)\n    The state is arranged as a 4x4 matrix in column-major order:\n    state[pos] where pos = row + 4 * column\n\n    Shift rows as:\n    Row 0: no shift\n    Row 1: shift left by 1\n    Row 2: shift left by 2\n    Row 3: shift left by 3\n    \"\"\"\n    rows = [state[i::4] for i in range(4)]  # extract rows\n\n    # Apply shifts\n    rows[1] = rows[1][1:] + rows[1][:1]\n    rows[2] = rows[2][2:] + rows[2][:2]\n    rows[3] = rows[3][3:] + rows[3][:3]\n\n    # Rebuild state in column-major order\n    shifted = []\n    for col in range(4):\n        for row in range(4):\n            shifted.append(rows[row][col])\n    return shifted\n\ndef add_round_key(state, round_key):\n    \"\"\"\n    XOR state with round key (both 16 bytes)\n    \"\"\"\n    return [s ^ k for s, k in zip(state, round_key)]\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on key size:\n    # Expanded key size: 176, 208, 240 bytes\n    # For 16-byte key: 10 rounds -> expanded key 176 bytes (16 * (10+1))\n    # For 24-byte key: 12 rounds -> expanded key 208 bytes\n    # For 32-byte key: 14 rounds -> expanded key 240 bytes\n    # Calculate number of rounds:\n    key_size_bytes = (len(expanded_key) // 16) - 1\n\n    # Initial round key addition\n    state = add_round_key(data, expanded_key[0:16])\n\n    # Rounds 1 to N-1\n    for round in range(1, key_size_bytes):\n        # SubBytes\n        state = sub_bytes(state)\n        # ShiftRows\n        state = shift_rows(state)\n        # MixColumns\n        state = mix_columns(state)\n        # AddRoundKey\n        round_key_start = round * 16\n        round_key_end = round_key_start + 16\n        state = add_round_key(state, expanded_key[round_key_start:round_key_end])\n\n    # Final round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = key_size_bytes * 16\n    round_key_end = round_key_start + 16\n    state = add_round_key(state, expanded_key[round_key_start:round_key_end])\n\n    return state", "from youtube_dl.aes import rijndael_mul, mix_column, mix_columns\n\n# Constants used in AES\nSBOX = [\n    # 256-byte S-box table for SubBytes step\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n]\n\n# MixColumns matrix for AES encryption\nMIX_COLUMN_MATRIX = [\n    [2, 3, 1, 1],\n    [1, 2, 3, 1],\n    [1, 1, 2, 3],\n    [3, 1, 1, 2]\n]\n\ndef sub_bytes(state):\n    \"\"\"\n    Apply S-box substitution to each byte in the state.\n    :param state: List[int] - 16-byte state\n    :return: List[int] - substituted state\n    \"\"\"\n    return [SBOX[b] for b in state]\n\n\ndef shift_rows(state):\n    \"\"\"\n    Perform the ShiftRows step on the state.\n    State is a list of 16 bytes arranged column-wise:\n    state[0..3]  = first column\n    state[4..7]  = second column\n    etc.\n\n    ShiftRows operates on the rows of the state (which in column-major is scattered),\n    so for proper row operations, the state is easiest to view as a 4x4 matrix\n    arranged column-wise, i.e., state arranged as:\n    [\n      state[0],  state[4],  state[8],  state[12],\n      state[1],  state[5],  state[9],  state[13],\n      state[2],  state[6],  state[10], state[14],\n      state[3],  state[7],  state[11], state[15]\n    ]\n    \n    But standard AES assumes state is arranged row-wise. Here we must carefully shift rows.\n    \n    The simplest way is to represent state as a 4x4 matrix row-wise,\n    then perform shift rows, and then flattened column-wise\n    \n    With column-major storage:\n      bytes:\n        c0: s0 s1 s2 s3   -> indices 0 1 2 3\n        c1: s4 s5 s6 s7   -> indices 4 5 6 7\n        c2: s8 s9 s10 s11 -> indices 8 9 10 11\n        c3: s12 s13 s14 s15 -> indices 12 13 14 15\n        \n    But the file content and AES standard use column-major order:\n    State matrix is:\n       [[state[0], state[4], state[8],  state[12]],\n        [state[1], state[5], state[9],  state[13]],\n        [state[2], state[6], state[10], state[14]],\n        [state[3], state[7], state[11], state[15]]]\n        \n    For ShiftRows, rows rotate left by their row index:\n    Row 0: no shift\n    Row 1: shift left by 1\n    Row 2: shift left by 2\n    Row 3: shift left by 3\n\n    We'll convert to 4x4 row-wise matrix, shift, then convert back col-wise.\n    \"\"\"\n    # Convert to row-wise 4x4 matrix\n    matrix = [[0]*4 for _ in range(4)]\n    for r in range(4):\n        for c in range(4):\n            matrix[r][c] = state[c*4 + r]\n\n    # Shift rows\n    for r in range(1, 4):\n        matrix[r] = matrix[r][r:] + matrix[r][:r]\n\n    # Convert back column-wise\n    shifted = [0]*16\n    for r in range(4):\n        for c in range(4):\n            shifted[c*4 + r] = matrix[r][c]\n\n    return shifted\n\n\ndef add_round_key(state, round_key):\n    \"\"\"\n    XOR the state with the round key.\n    \n    :param state: List[int] 16 bytes\n    :param round_key: List[int] 16 bytes\n    :return: List[int] 16 bytes\n    \"\"\"\n    return [b ^ k for b, k in zip(state, round_key)]\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on key length:\n    # Expanded key lengths:\n    # 176 bytes -> 10 rounds (AES-128)\n    # 208 bytes -> 12 rounds (AES-192)\n    # 240 bytes -> 14 rounds (AES-256)\n    expanded_key_len = len(expanded_key)\n    if expanded_key_len == 176:\n        rounds = 10\n    elif expanded_key_len == 208:\n        rounds = 12\n    elif expanded_key_len == 240:\n        rounds = 14\n    else:\n        raise ValueError(\"Invalid expanded key length\")\n\n    state = data[:]\n\n    # Initial round key addition\n    state = add_round_key(state, expanded_key[:16])\n\n    # Main rounds\n    for round_idx in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state, MIX_COLUMN_MATRIX)\n        round_key = expanded_key[round_idx * 16 : (round_idx + 1) * 16]\n        state = add_round_key(state, round_key)\n\n    # Final round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key = expanded_key[rounds * 16 : (rounds + 1) * 16]\n    state = add_round_key(state, round_key)\n\n    return state", "from youtube_dl.aes import mix_columns\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on the expanded key size:\n    # For 16-byte key: 10 rounds, for 24-byte: 12 rounds, for 32-byte: 14 rounds\n    # expanded_key size = (Nr + 1) * 16, so:\n    key_len = len(expanded_key)\n    round_count = {176: 10, 208: 12, 240: 14}[key_len]\n\n    state = data[:]  # Copy input state\n\n    # Helper functions\n    def sub_bytes(s):\n        # Applies S-box substitution to each byte of the state\n        return [S_BOX[b] for b in s]\n\n    def shift_rows(s):\n        # Shift rows according to AES specification\n        # State is represented as a flat list of 16 bytes, column-major order:\n        # Indices:\n        #  0  4  8 12\n        #  1  5  9 13\n        #  2  6 10 14\n        #  3  7 11 15\n        # Shift rows:\n        # Row 0: no shift\n        # Row 1: shift left by 1\n        # Row 2: shift left by 2\n        # Row 3: shift left by 3\n        s2 = s[:]\n        # Row 1:\n        s2[1], s2[5], s2[9], s2[13] = s[5], s[9], s[13], s[1]\n        # Row 2:\n        s2[2], s2[6], s2[10], s2[14] = s[10], s[14], s[2], s[6]\n        # Row 3:\n        s2[3], s2[7], s2[11], s2[15] = s[15], s[3], s[7], s[11]\n        return s2\n\n    def add_round_key(s, rk):\n        # XOR the state with round key rk (16 bytes)\n        return [a ^ b for a, b in zip(s, rk)]\n\n    # S-box used in AES\n    S_BOX = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n    ]\n\n    # Initial AddRoundKey (round 0)\n    state = add_round_key(state, expanded_key[0:16])\n\n    # Rounds 1 to Nr-1\n    for round_i in range(1, round_count):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = add_round_key(state, expanded_key[round_i * 16:(round_i + 1) * 16])\n\n    # Final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = add_round_key(state, expanded_key[round_count * 16:(round_count + 1) * 16])\n\n    return state"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom youtube_dl.aes import mix_columns\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on key size (expanded key length)\n    # 16-byte key -> 10 rounds, 24-byte key -> 12 rounds, 32-byte key -> 14 rounds\n    # expanded_key length is 176, 208 or 240 bytes respectively\n    Nr = (len(expanded_key) // 16) - 1\n\n    # Copy input data to state (list of 16 ints)\n    state = data[:]\n\n    # AddRoundKey - initial round key addition\n    for i in range(16):\n        state[i] ^= expanded_key[i]\n\n    # For rounds 1 to Nr-1 do the main rounds\n    for round_idx in range(1, Nr):\n        # SubBytes (using sub_bytes on state)\n        state = sub_bytes(state)\n\n        # ShiftRows (using shift_rows on state)\n        state = shift_rows(state)\n\n        # MixColumns\n        state = mix_columns(state)\n\n        # AddRoundKey\n        round_key_start = round_idx * 16\n        for i in range(16):\n            state[i] ^= expanded_key[round_key_start + i]\n\n    # Final round (Nr-th round) without MixColumns\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = Nr * 16\n    for i in range(16):\n        state[i] ^= expanded_key[round_key_start + i]\n\n    return state\n\n\n# The sub_bytes and shift_rows functions are needed here.\n# They should be defined or imported accordingly.\n# Since only aes_encrypt is requested and no imports from file content,\n# we provide implementations for sub_bytes and shift_rows below:\n\nS_BOX = [\n    # 256-element AES S-box\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]\n\n\ndef sub_bytes(state):\n    \"\"\"Apply the AES S-box substitution to each byte of the state.\"\"\"\n    return [S_BOX[b] for b in state]\n\n\ndef shift_rows(state):\n    \"\"\"\n    Shift rows in the AES state.\n    The state array is indexed as a 4x4 matrix in column-major order:\n    state = [s0, s1, s2, s3, ..., s15]\n    where columns (each of 4 bytes) are contiguous every 4 bytes:\n    index = row + 4 * column\n    Shift rows:\n     - row 0: no shift\n     - row 1: shift left by 1\n     - row 2: shift left by 2\n     - row 3: shift left by 3\n    \"\"\"\n    # Convert to 4x4 matrix (row-major for ease)\n    matrix = [[0]*4 for _ in range(4)]  # matrix[row][col]\n\n    for i in range(16):\n        row = i % 4\n        col = i // 4\n        matrix[row][col] = state[i]\n\n    # Shift rows\n    for r in range(1, 4):\n        matrix[r] = matrix[r][r:] + matrix[r][:r]\n\n    # Convert back to state (column-major)\n    new_state = [0]*16\n    for r in range(4):\n        for c in range(4):\n            new_state[c*4 + r] = matrix[r][c]\n\n    return new_state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom youtube_dl.aes import mix_columns\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of 32-bit words comprising the cipher key\n    key_len = len(expanded_key)\n    if key_len == 176:  # 16 bytes key => 10 rounds + 1 initial key addition\n        rounds = 10\n    elif key_len == 208:  # 24 bytes key => 12 rounds + 1 initial key addition\n        rounds = 12\n    elif key_len == 240:  # 32 bytes key => 14 rounds + 1 initial key addition\n        rounds = 14\n    else:\n        raise ValueError(\"Invalid expanded_key length\")\n\n    state = data[:]\n\n    # Initial AddRoundKey\n    for i in range(16):\n        state[i] ^= expanded_key[i]\n\n    # Each round is 16 bytes = 4 words\n    # Helper to get the key slice for a round\n    def round_key(r):\n        start = 16 * r\n        return expanded_key[start:start + 16]\n\n    for r in range(1, rounds):\n        # SubBytes\n        state = sub_bytes(state)\n\n        # ShiftRows\n        state = shift_rows(state)\n\n        # MixColumns\n        state = mix_columns(state)\n\n        # AddRoundKey\n        rk = round_key(r)\n        for i in range(16):\n            state[i] ^= rk[i]\n\n    # Last round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    rk = round_key(rounds)\n    for i in range(16):\n        state[i] ^= rk[i]\n\n    return state\n\n\n# Helper functions needed for aes_encrypt (based on AES standard and typical implementations)\n# These are not provided in the context, but are essential.\n# Implementations follow the typical AES specification.\n\n\n# The S-box used by AES (256 values)\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]\n\n\ndef sub_bytes(state):\n    \"\"\"Substitute each byte in the state using the AES S-box\"\"\"\n    return [SBOX[b] for b in state]\n\n\ndef shift_rows(state):\n    \"\"\"Shift rows for AES state; input/output are 16-byte lists\"\"\"\n    # State is in row-major order: state[row + 4 * col]\n    # ShiftRows shifts bytes at rows:\n    # Row 0: no shift\n    # Row 1: shift left by 1\n    # Row 2: shift left by 2\n    # Row 3: shift left by 3\n\n    # Convert to 4x4 matrix (row-major)\n    matrix = [state[i*4:(i+1)*4] for i in range(4)]\n\n    for r in range(1, 4):\n        matrix[r] = matrix[r][r:] + matrix[r][:r]\n\n    # Flatten back to list\n    return [matrix[i][j] for i in range(4) for j in range(4)]\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom youtube_dl.aes import mix_columns\n\n\n# S-box for SubBytes step\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]\n\n# RCON for AddRoundKey in Key Expansion, not needed here but included for completeness\n\ndef sub_bytes(state):\n    \"\"\"\n    Perform SubBytes step of AES:\n    Substitute each byte in state using the SBOX.\n    \"\"\"\n    return [SBOX[b] for b in state]\n\ndef shift_rows(state):\n    \"\"\"\n    Perform ShiftRows step of AES on a 16-byte state (list)\n    The state is arranged as a 4x4 matrix in column-major order:\n    state[pos] where pos = row + 4 * column\n\n    Shift rows as:\n    Row 0: no shift\n    Row 1: shift left by 1\n    Row 2: shift left by 2\n    Row 3: shift left by 3\n    \"\"\"\n    rows = [state[i::4] for i in range(4)]  # extract rows\n\n    # Apply shifts\n    rows[1] = rows[1][1:] + rows[1][:1]\n    rows[2] = rows[2][2:] + rows[2][:2]\n    rows[3] = rows[3][3:] + rows[3][:3]\n\n    # Rebuild state in column-major order\n    shifted = []\n    for col in range(4):\n        for row in range(4):\n            shifted.append(rows[row][col])\n    return shifted\n\ndef add_round_key(state, round_key):\n    \"\"\"\n    XOR state with round key (both 16 bytes)\n    \"\"\"\n    return [s ^ k for s, k in zip(state, round_key)]\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on key size:\n    # Expanded key size: 176, 208, 240 bytes\n    # For 16-byte key: 10 rounds -> expanded key 176 bytes (16 * (10+1))\n    # For 24-byte key: 12 rounds -> expanded key 208 bytes\n    # For 32-byte key: 14 rounds -> expanded key 240 bytes\n    # Calculate number of rounds:\n    key_size_bytes = (len(expanded_key) // 16) - 1\n\n    # Initial round key addition\n    state = add_round_key(data, expanded_key[0:16])\n\n    # Rounds 1 to N-1\n    for round in range(1, key_size_bytes):\n        # SubBytes\n        state = sub_bytes(state)\n        # ShiftRows\n        state = shift_rows(state)\n        # MixColumns\n        state = mix_columns(state)\n        # AddRoundKey\n        round_key_start = round * 16\n        round_key_end = round_key_start + 16\n        state = add_round_key(state, expanded_key[round_key_start:round_key_end])\n\n    # Final round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = key_size_bytes * 16\n    round_key_end = round_key_start + 16\n    state = add_round_key(state, expanded_key[round_key_start:round_key_end])\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom youtube_dl.aes import rijndael_mul, mix_column, mix_columns\n\n# Constants used in AES\nSBOX = [\n    # 256-byte S-box table for SubBytes step\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n]\n\n# MixColumns matrix for AES encryption\nMIX_COLUMN_MATRIX = [\n    [2, 3, 1, 1],\n    [1, 2, 3, 1],\n    [1, 1, 2, 3],\n    [3, 1, 1, 2]\n]\n\ndef sub_bytes(state):\n    \"\"\"\n    Apply S-box substitution to each byte in the state.\n    :param state: List[int] - 16-byte state\n    :return: List[int] - substituted state\n    \"\"\"\n    return [SBOX[b] for b in state]\n\n\ndef shift_rows(state):\n    \"\"\"\n    Perform the ShiftRows step on the state.\n    State is a list of 16 bytes arranged column-wise:\n    state[0..3]  = first column\n    state[4..7]  = second column\n    etc.\n\n    ShiftRows operates on the rows of the state (which in column-major is scattered),\n    so for proper row operations, the state is easiest to view as a 4x4 matrix\n    arranged column-wise, i.e., state arranged as:\n    [\n      state[0],  state[4],  state[8],  state[12],\n      state[1],  state[5],  state[9],  state[13],\n      state[2],  state[6],  state[10], state[14],\n      state[3],  state[7],  state[11], state[15]\n    ]\n    \n    But standard AES assumes state is arranged row-wise. Here we must carefully shift rows.\n    \n    The simplest way is to represent state as a 4x4 matrix row-wise,\n    then perform shift rows, and then flattened column-wise\n    \n    With column-major storage:\n      bytes:\n        c0: s0 s1 s2 s3   -> indices 0 1 2 3\n        c1: s4 s5 s6 s7   -> indices 4 5 6 7\n        c2: s8 s9 s10 s11 -> indices 8 9 10 11\n        c3: s12 s13 s14 s15 -> indices 12 13 14 15\n        \n    But the file content and AES standard use column-major order:\n    State matrix is:\n       [[state[0], state[4], state[8],  state[12]],\n        [state[1], state[5], state[9],  state[13]],\n        [state[2], state[6], state[10], state[14]],\n        [state[3], state[7], state[11], state[15]]]\n        \n    For ShiftRows, rows rotate left by their row index:\n    Row 0: no shift\n    Row 1: shift left by 1\n    Row 2: shift left by 2\n    Row 3: shift left by 3\n\n    We'll convert to 4x4 row-wise matrix, shift, then convert back col-wise.\n    \"\"\"\n    # Convert to row-wise 4x4 matrix\n    matrix = [[0]*4 for _ in range(4)]\n    for r in range(4):\n        for c in range(4):\n            matrix[r][c] = state[c*4 + r]\n\n    # Shift rows\n    for r in range(1, 4):\n        matrix[r] = matrix[r][r:] + matrix[r][:r]\n\n    # Convert back column-wise\n    shifted = [0]*16\n    for r in range(4):\n        for c in range(4):\n            shifted[c*4 + r] = matrix[r][c]\n\n    return shifted\n\n\ndef add_round_key(state, round_key):\n    \"\"\"\n    XOR the state with the round key.\n    \n    :param state: List[int] 16 bytes\n    :param round_key: List[int] 16 bytes\n    :return: List[int] 16 bytes\n    \"\"\"\n    return [b ^ k for b, k in zip(state, round_key)]\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on key length:\n    # Expanded key lengths:\n    # 176 bytes -> 10 rounds (AES-128)\n    # 208 bytes -> 12 rounds (AES-192)\n    # 240 bytes -> 14 rounds (AES-256)\n    expanded_key_len = len(expanded_key)\n    if expanded_key_len == 176:\n        rounds = 10\n    elif expanded_key_len == 208:\n        rounds = 12\n    elif expanded_key_len == 240:\n        rounds = 14\n    else:\n        raise ValueError(\"Invalid expanded key length\")\n\n    state = data[:]\n\n    # Initial round key addition\n    state = add_round_key(state, expanded_key[:16])\n\n    # Main rounds\n    for round_idx in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state, MIX_COLUMN_MATRIX)\n        round_key = expanded_key[round_idx * 16 : (round_idx + 1) * 16]\n        state = add_round_key(state, round_key)\n\n    # Final round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key = expanded_key[rounds * 16 : (rounds + 1) * 16]\n    state = add_round_key(state, round_key)\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom youtube_dl.aes import mix_columns\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on the expanded key size:\n    # For 16-byte key: 10 rounds, for 24-byte: 12 rounds, for 32-byte: 14 rounds\n    # expanded_key size = (Nr + 1) * 16, so:\n    key_len = len(expanded_key)\n    round_count = {176: 10, 208: 12, 240: 14}[key_len]\n\n    state = data[:]  # Copy input state\n\n    # Helper functions\n    def sub_bytes(s):\n        # Applies S-box substitution to each byte of the state\n        return [S_BOX[b] for b in s]\n\n    def shift_rows(s):\n        # Shift rows according to AES specification\n        # State is represented as a flat list of 16 bytes, column-major order:\n        # Indices:\n        #  0  4  8 12\n        #  1  5  9 13\n        #  2  6 10 14\n        #  3  7 11 15\n        # Shift rows:\n        # Row 0: no shift\n        # Row 1: shift left by 1\n        # Row 2: shift left by 2\n        # Row 3: shift left by 3\n        s2 = s[:]\n        # Row 1:\n        s2[1], s2[5], s2[9], s2[13] = s[5], s[9], s[13], s[1]\n        # Row 2:\n        s2[2], s2[6], s2[10], s2[14] = s[10], s[14], s[2], s[6]\n        # Row 3:\n        s2[3], s2[7], s2[11], s2[15] = s[15], s[3], s[7], s[11]\n        return s2\n\n    def add_round_key(s, rk):\n        # XOR the state with round key rk (16 bytes)\n        return [a ^ b for a, b in zip(s, rk)]\n\n    # S-box used in AES\n    S_BOX = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n    ]\n\n    # Initial AddRoundKey (round 0)\n    state = add_round_key(state, expanded_key[0:16])\n\n    # Rounds 1 to Nr-1\n    for round_i in range(1, round_count):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = add_round_key(state, expanded_key[round_i * 16:(round_i + 1) * 16])\n\n    # Final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = add_round_key(state, expanded_key[round_count * 16:(round_count + 1) * 16])\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n"]}
{"task_id": 150, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from math import ceil\nfrom youtube_dl.aes import shift_rows_inv, mix_columns_inv\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    # Initial AddRoundKey (last round key)\n    data = xor(data, expanded_key[rounds * 16: (rounds + 1) * 16])\n\n    # Perform rounds in reverse order\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)  # We need the inverse of sub_bytes (not given in context but must exist)\n        data = xor(data, expanded_key[i * 16: (i + 1) * 16])\n        data = mix_columns_inv(data)\n\n    # Final round (no mix_columns_inv)\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:16])\n\n    return data\n\n# Helper functions xor and sub_bytes_inv must be defined for correctness.\n# From file content, xor presumably is defined somewhere else, so we define it here:\ndef xor(a, b):\n    return [x ^ y for x, y in zip(a, b)]\n\n# The inverse S-box substitution (sub_bytes_inv) is not provided in the context.\n# We must implement or import it. Since not provided, we provide a placeholder.\n\n# Placeholder for inverse substitution bytes function\n# In the original codebase this should be implemented similar to sub_bytes but inverse.\ndef sub_bytes_inv(data):\n    # This is a stub implementation; in the actual codebase, it should perform the inverse S-box substitution.\n    # Since `sub_bytes` is used in encryption, decryption requires inverse table.\n    # Without the actual S-box inverse table this cannot be implemented correctly here.\n    raise NotImplementedError(\"Inverse substitute bytes function (sub_bytes_inv) is not implemented.\")", "from youtube_dl.aes import shift_rows_inv, mix_columns_inv\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16:(rounds + 1) * 16])\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * 16: (i + 1) * 16])\n        data = mix_columns_inv(data)\n\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:16])\n\n    return data\n\n\n# Helper functions required but not provided in context (must be implemented here)\n\n# AES Inverse S-box for sub_bytes_inv\nINVERSE_SBOX = [\n    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,\n    0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,\n    0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,\n    0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,\n    0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,\n    0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,\n    0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,\n    0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,\n    0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,\n    0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,\n    0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,\n    0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,\n    0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,\n    0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,\n    0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,\n    0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,\n    0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,\n]\n\ndef sub_bytes_inv(state):\n    \"\"\"Apply inverse S-box substitution to each byte in the state.\"\"\"\n    return [INVERSE_SBOX[b] for b in state]\n\n\ndef xor(a, b):\n    \"\"\"XOR two lists of integers bytewise.\"\"\"\n    return [x ^ y for x, y in zip(a, b)]", "from youtube_dl.aes import shift_rows_inv, mix_columns_inv\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16:(rounds + 1) * 16])\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * 16:(i + 1) * 16])\n        data = mix_columns_inv(data)\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:16])\n\n    return data\n\n\ndef xor(a, b):\n    return [x ^ y for x, y in zip(a, b)]\n\n\ndef sub_bytes_inv(state):\n    \"\"\"\n    Apply the inverse S-box (substitution box) transformation to the given state.\n    This is required for AES decryption.\n\n    :param state: list of 16 ints (bytes)\n    :return: list of 16 ints after inverse substitution\n    \"\"\"\n    INV_SBOX = [\n        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,\n        0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,\n        0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,\n        0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,\n        0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,\n        0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,\n        0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,\n        0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,\n        0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,\n        0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,\n        0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,\n        0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,\n        0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,\n        0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,\n        0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,\n        0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,\n        0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,\n    ]\n    return [INV_SBOX[b] for b in state]", "from youtube_dl.aes import shift_rows_inv, mix_columns_inv\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16:(rounds + 1) * 16])\n    for i in range(rounds - 1, -1, -1):\n        data = shift_rows_inv(data)\n        data = xor(data, expanded_key[i * 16:(i + 1) * 16])\n        if i != 0:\n            data = mix_columns_inv(data)\n\n    return data\n\n\ndef xor(a, b):\n    return [x ^ y for x, y in zip(a, b)]", "from youtube_dl.aes import shift_rows_inv, mix_columns_inv\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16:(rounds + 1) * 16])  # last round key addition\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * 16:(i + 1) * 16])\n        data = mix_columns_inv(data)\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:16])\n\n    return data"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import shift_rows_inv, mix_columns_inv\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    # Initial AddRoundKey (last round key)\n    data = xor(data, expanded_key[rounds * 16: (rounds + 1) * 16])\n\n    # Perform rounds in reverse order\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)  # We need the inverse of sub_bytes (not given in context but must exist)\n        data = xor(data, expanded_key[i * 16: (i + 1) * 16])\n        data = mix_columns_inv(data)\n\n    # Final round (no mix_columns_inv)\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:16])\n\n    return data\n\n# Helper functions xor and sub_bytes_inv must be defined for correctness.\n# From file content, xor presumably is defined somewhere else, so we define it here:\ndef xor(a, b):\n    return [x ^ y for x, y in zip(a, b)]\n\n# The inverse S-box substitution (sub_bytes_inv) is not provided in the context.\n# We must implement or import it. Since not provided, we provide a placeholder.\n\n# Placeholder for inverse substitution bytes function\n# In the original codebase this should be implemented similar to sub_bytes but inverse.\ndef sub_bytes_inv(data):\n    # This is a stub implementation; in the actual codebase, it should perform the inverse S-box substitution.\n    # Since `sub_bytes` is used in encryption, decryption requires inverse table.\n    # Without the actual S-box inverse table this cannot be implemented correctly here.\n    raise NotImplementedError(\"Inverse substitute bytes function (sub_bytes_inv) is not implemented.\")\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom youtube_dl.aes import shift_rows_inv, mix_columns_inv\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16:(rounds + 1) * 16])\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * 16: (i + 1) * 16])\n        data = mix_columns_inv(data)\n\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:16])\n\n    return data\n\n\n# Helper functions required but not provided in context (must be implemented here)\n\n# AES Inverse S-box for sub_bytes_inv\nINVERSE_SBOX = [\n    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,\n    0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,\n    0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,\n    0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,\n    0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,\n    0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,\n    0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,\n    0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,\n    0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,\n    0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,\n    0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,\n    0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,\n    0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,\n    0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,\n    0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,\n    0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,\n    0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,\n]\n\ndef sub_bytes_inv(state):\n    \"\"\"Apply inverse S-box substitution to each byte in the state.\"\"\"\n    return [INVERSE_SBOX[b] for b in state]\n\n\ndef xor(a, b):\n    \"\"\"XOR two lists of integers bytewise.\"\"\"\n    return [x ^ y for x, y in zip(a, b)]\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom youtube_dl.aes import shift_rows_inv, mix_columns_inv\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16:(rounds + 1) * 16])\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * 16:(i + 1) * 16])\n        data = mix_columns_inv(data)\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:16])\n\n    return data\n\n\ndef xor(a, b):\n    return [x ^ y for x, y in zip(a, b)]\n\n\ndef sub_bytes_inv(state):\n    \"\"\"\n    Apply the inverse S-box (substitution box) transformation to the given state.\n    This is required for AES decryption.\n\n    :param state: list of 16 ints (bytes)\n    :return: list of 16 ints after inverse substitution\n    \"\"\"\n    INV_SBOX = [\n        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,\n        0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,\n        0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,\n        0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,\n        0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,\n        0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,\n        0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,\n        0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,\n        0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,\n        0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,\n        0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,\n        0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,\n        0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,\n        0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,\n        0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,\n        0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,\n        0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,\n    ]\n    return [INV_SBOX[b] for b in state]\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom youtube_dl.aes import shift_rows_inv, mix_columns_inv\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16:(rounds + 1) * 16])\n    for i in range(rounds - 1, -1, -1):\n        data = shift_rows_inv(data)\n        data = xor(data, expanded_key[i * 16:(i + 1) * 16])\n        if i != 0:\n            data = mix_columns_inv(data)\n\n    return data\n\n\ndef xor(a, b):\n    return [x ^ y for x, y in zip(a, b)]\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom youtube_dl.aes import shift_rows_inv, mix_columns_inv\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // 16 - 1\n\n    data = xor(data, expanded_key[rounds * 16:(rounds + 1) * 16])  # last round key addition\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * 16:(i + 1) * 16])\n        data = mix_columns_inv(data)\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:16])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n"]}
{"task_id": 151, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from math import ceil\nfrom youtube_dl.aes import aes_ctr_decrypt, aes_encrypt, key_expansion, xor\nfrom youtube_dl.aes import BLOCK_SIZE_BYTES\nfrom youtube_dl.compat import compat_b64decode\n\n\nclass Counter:\n    def __init__(self, high_bytes):\n        \"\"\"\n        Counter instance for AES CTR mode.\n\n        @param {int[]} high_bytes 8 Bytes list representing the high bytes of the counter\n        \"\"\"\n        if len(high_bytes) != 8:\n            raise ValueError(\"High bytes length must be 8\")\n        self.high_bytes = high_bytes[:]\n        self.low_bytes = [0] * 8\n\n    def next_value(self):\n        \"\"\"\n        Return the next 16-Bytes counter block as list of ints:\n        8 bytes high + 8 bytes low. Low part increments on every call.\n\n        @returns {int[]} 16-Byte counter block\n        \"\"\"\n        # Increment low_bytes as 64-bit integer (little endian)\n        carry = 1\n        for i in range(7, -1, -1):\n            new_val = self.low_bytes[i] + carry\n            self.low_bytes[i] = new_val & 0xFF\n            carry = new_val >> 8\n            if carry == 0:\n                break\n\n        return self.high_bytes + self.low_bytes\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Decode base64-encoded data to bytes\n    decoded_bytes = compat_b64decode(data)\n    if len(decoded_bytes) < 8:\n        raise ValueError(\"Decoded data too short to contain counter high bytes\")\n\n    # Extract the first 8 bytes: high bytes of the counter\n    high_bytes = list(decoded_bytes[:8])\n\n    # The rest is the cipher text\n    ciphertext = list(decoded_bytes[8:])\n\n    # Encode password in utf-8 to bytes\n    password_bytes = password.encode('utf-8')\n\n    # Prepare the cipher key:\n    # - Take the first 'key_size_bytes' bytes from password_bytes, pad with zeros if needed\n    key_bytes = list(password_bytes[:key_size_bytes])\n    if len(key_bytes) < key_size_bytes:\n        key_bytes += [0] * (key_size_bytes - len(key_bytes))\n\n    # Take first 16 bytes of password_bytes (or pad with 0s if shorter) as block for encryption\n    block_for_key = list(password_bytes[:16])\n    if len(block_for_key) < 16:\n        block_for_key += [0] * (16 - len(block_for_key))\n\n    # Expand the key\n    expanded_key = key_expansion(key_bytes)\n\n    # Derive the AES key by encrypting block_for_key with expanded_key\n    derived_key = aes_encrypt(block_for_key, expanded_key)\n\n    # Use the derived key for decryption in counter mode\n    counter = Counter(high_bytes)\n    decrypted_ints = aes_ctr_decrypt(ciphertext, derived_key, counter)\n\n    # Convert decrypted ints to bytes and then decode UTF-8 string\n    decrypted_bytes = bytes(decrypted_ints)\n    return decrypted_bytes.decode('utf-8')", "from math import ceil\nfrom youtube_dl.aes import aes_ctr_decrypt, aes_encrypt, key_expansion\nfrom youtube_dl.compat import compat_b64decode\n\n\nclass AESCounter:\n    def __init__(self, high_bytes):\n        \"\"\"\n        Counter class for AES CTR mode.\n        The counter block is 16 bytes long; the first 8 bytes are zeros,\n        the next 8 bytes are the high_bytes plus a low 8-byte incrementing counter.\n        \"\"\"\n        self.high_bytes = high_bytes  # 8 bytes (int list)\n        self.low = 0\n\n    def next_value(self):\n        # low is 8-byte little-endian integer increment\n        low_bytes = []\n        n = self.low\n        for _ in range(8):\n            low_bytes.append(n & 0xFF)\n            n >>= 8\n        self.low += 1\n\n        # Construct the 16-byte counter block:\n        #  first 8 bytes zero + low_bytes (8 bytes) XORed with high_bytes (8 bytes)\n        # But specification says: \"The first 8 bytes of decoded data are the 8 high bytes of the counter\",\n        # likely the first 8 bytes are high_bytes, then we combine with low counter in last 8 bytes.\n        # According to common CTR usage, counter block = high 8 bytes + low 8 bytes.\n\n        # So counter block = high_bytes (8 bytes) + low_bytes (8 bytes)\n        counter_block = self.high_bytes[:] + low_bytes\n\n        return counter_block\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Decode base64 input data to bytes\n    decoded_data = compat_b64decode(data)\n\n    # Convert decoded_data bytes to list of ints for aes functions\n    data_ints = list(decoded_data)\n\n    # The first 8 bytes of data_ints are the \"high bytes\" of the counter\n    counter_high_bytes = data_ints[:8]\n\n    # The rest is the encrypted content\n    encrypted_data = data_ints[8:]\n\n    # Prepare password key bytes list (utf-8)\n    password_bytes = password.encode('utf-8')\n\n    # Prepare the 'key' with length key_size_bytes with zeros padding if shorter\n    key = list(password_bytes[:key_size_bytes]) + [0] * max(0, key_size_bytes - len(password_bytes))\n\n    # Prepare the first 16 bytes of password padded similarly (for encryption)\n    first_16_password_bytes = list(password_bytes[:16]) + [0] * max(0, 16 - len(password_bytes))\n\n    # Encrypt the first_16_password_bytes with the key to get the cipher key\n    expanded_key = key_expansion(key)\n    cipher_key = aes_encrypt(first_16_password_bytes, expanded_key)  # returns list of 16 ints\n\n    # Create the counter instance with the 8 high bytes\n    counter = AESCounter(counter_high_bytes)\n\n    # Decrypt with AES CTR mode, using the derived cipher key\n    decrypted_ints = aes_ctr_decrypt(encrypted_data, cipher_key, counter)\n\n    # Convert decrypted bytes (list of ints) back to utf-8 string\n    decrypted_bytes = bytes(decrypted_ints)\n    try:\n        decrypted_text = decrypted_bytes.decode('utf-8')\n    except UnicodeDecodeError:\n        # If decoding fails, return raw bytes string fallback\n        decrypted_text = decrypted_bytes.decode('latin1', errors='replace')\n\n    return decrypted_text", "from math import ceil\nfrom youtube_dl.aes import aes_ctr_decrypt, aes_encrypt, key_expansion\nfrom youtube_dl.compat import compat_b64decode\n\n\nclass Counter:\n    def __init__(self, high_bytes):\n        \"\"\"\n        Initialize the counter object with the first 8 bytes as the high part\n        and the low part initialized to 0.\n        \"\"\"\n        self.high_bytes = high_bytes  # 8 bytes list\n        self.low = 0\n\n    def next_value(self):\n        \"\"\"\n        Returns the next 16-Byte counter block:\n        - first 8 bytes are fixed high_bytes\n        - last 8 bytes are low counter, incremented for each call\n        \n        Represent low as 8-byte big-endian integer.\n        \"\"\"\n        low_bytes = []\n        v = self.low\n        for _ in range(8):\n            low_bytes.append(v & 0xFF)\n            v >>= 8\n        low_bytes.reverse()\n\n        self.low += 1\n        return self.high_bytes + low_bytes\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Step 1: Base64 decode data -> bytes list (int list)\n    decoded_bytes = compat_b64decode(data)\n    data_bytes = list(decoded_bytes)\n\n    # Extract first 8 bytes of data_bytes as high bytes of counter\n    counter_high = data_bytes[:8]\n\n    # The rest of data_bytes after the 8 bytes is the ciphertext\n    ciphertext = data_bytes[8:]\n\n    # Step 2: Prepare password key bytes\n    password_bytes = list(password.encode('utf-8'))\n\n    # Extract key for cipher key derivation: first key_size_bytes of password, padded with 0s if short\n    key_for_key = password_bytes[:key_size_bytes]\n    if len(key_for_key) < key_size_bytes:\n        key_for_key += [0] * (key_size_bytes - len(key_for_key))\n\n    # The data to encrypt to get the actual cipher key is first 16 bytes of password\n    # If password is less than 16 bytes, pad with 0s\n    key_data = password_bytes[:16]\n    if len(key_data) < 16:\n        key_data += [0] * (16 - len(key_data))\n\n    # Step 3: Generate actual cipher key by encrypting key_data with key_for_key\n    expanded_key = key_expansion(key_for_key)\n    cipher_key = aes_encrypt(key_data, expanded_key)\n\n    # Step 4: Use cipher_key in AES CTR mode with counter initialized to counter_high to decrypt ciphertext\n    counter = Counter(counter_high)\n    decrypted_intlist = aes_ctr_decrypt(ciphertext, cipher_key, counter)\n\n    # Step 5: Convert decrypted int list to bytes and decode as UTF-8 string\n    decrypted_bytes = bytes(decrypted_intlist)\n    return decrypted_bytes.decode('utf-8')", "from math import ceil\nfrom youtube_dl.aes import aes_ctr_decrypt, aes_encrypt, key_expansion\nfrom youtube_dl.compat import compat_b64decode\n\n\nclass Counter:\n    \"\"\"\n    Counter class for AES counter mode encryption/decryption.\n    Initialized with the 8 high bytes. The 8 low bytes of the counter start at 0 and increment by 1 each call.\n    \"\"\"\n\n    def __init__(self, high_bytes):\n        # high_bytes: list of 8 ints\n        self.high = high_bytes[:]  # make a copy\n        self.low = 0\n\n    def next_value(self):\n        # return 16-byte list = high 8 bytes + low 8 bytes (little endian)\n        low_bytes = []\n        temp = self.low\n        for _ in range(8):\n            low_bytes.append(temp & 0xFF)\n            temp >>= 8\n        self.low += 1\n        return self.high + low_bytes\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n\n    # Decode base64 encoded data into bytes\n    decoded_bytes = list(compat_b64decode(data))\n\n    # The first 8 bytes are the high 8 bytes of the counter\n    counter_high_bytes = decoded_bytes[:8]\n\n    # The rest is the ciphertext to decrypt\n    cipher_bytes = decoded_bytes[8:]\n\n    # Prepare the key\n    password_bytes = password.encode('utf-8')\n\n    # The key bytes part: first key_size_bytes from password, padded with zeros if needed\n    key_bytes = list(password_bytes[:key_size_bytes])\n    if len(key_bytes) < key_size_bytes:\n        key_bytes += [0] * (key_size_bytes - len(key_bytes))\n\n    # The first 16 bytes to be encrypted to get the actual cipher key.\n    # If password_bytes less than 16 bytes, pad with zeros\n    first_16_bytes = list(password_bytes[:16])\n    if len(first_16_bytes) < 16:\n        first_16_bytes += [0] * (16 - len(first_16_bytes))\n\n    # Expand key for encrypting first_16_bytes\n    expanded_key = key_expansion(key_bytes)\n\n    # Encrypt first_16_bytes with the prepared key to get cipher_key\n    cipher_key = aes_encrypt(first_16_bytes, expanded_key)\n\n    # Setup counter object with the high 8 bytes\n    counter = Counter(counter_high_bytes)\n\n    # Decrypt cipher_bytes using AES CTR mode with cipher_key and counter\n    decrypted_intlist = aes_ctr_decrypt(cipher_bytes, cipher_key, counter)\n\n    # Convert decrypted int list to bytes and decode to utf-8 string\n    decrypted_bytes = bytes(decrypted_intlist)\n    result = decrypted_bytes.decode('utf-8', errors='replace')\n\n    return result", "from math import ceil\nfrom youtube_dl.aes import aes_ctr_decrypt, aes_encrypt, key_expansion\nfrom youtube_dl.compat import compat_b64decode\n\n\nclass AESCounter:\n    \"\"\"\n    Counter class for AES-CTR mode.\n    Initializes with a 16-byte counter block.\n    The next_value method returns the current counter value and increments the counter by 1 (little-endian).\n    \"\"\"\n    def __init__(self, initial_counter):\n        self.counter = initial_counter[:]\n\n    def next_value(self):\n        # Return current counter value and increment it by 1 (little-endian)\n        current = self.counter[:]\n        # Increment counter by 1 (treat as little-endian integer)\n        for i in range(len(self.counter)):\n            self.counter[i] = (self.counter[i] + 1) & 0xff\n            if self.counter[i] != 0:\n                break\n        return current\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Step 1: Decode base64 data to bytes\n    data_bytes = compat_b64decode(data)\n\n    # data_bytes must be at least 8 bytes for high bytes of counter and some cipher data\n    if len(data_bytes) < 8:\n        return ''\n\n    # Step 2: Password to bytes (utf-8)\n    password_bytes = password.encode('utf-8')\n\n    # Step 3: Prepare the key: first key_size_bytes from password_bytes, zero-padded if needed\n    key = list(password_bytes[:key_size_bytes])\n    if len(key) < key_size_bytes:\n        key += [0] * (key_size_bytes - len(key))\n\n    # Step 4: Prepare first 16 bytes of password (for encryption to get the cipher key)\n    # If password_bytes shorter than 16, pad with zeros\n    password_block = list(password_bytes[:16])\n    if len(password_block) < 16:\n        password_block += [0] * (16 - len(password_block))\n\n    # Step 5: Expand key and encrypt password_block to get cipher key\n    expanded_key = key_expansion(key)\n    cipher_key = aes_encrypt(password_block, expanded_key)\n\n    # Step 6: Extract 8 high bytes of counter from data (first 8 bytes)\n    # Counter is 16 bytes: first 8 bytes are the high bytes given by data_bytes[:8]\n    # The lower 8 bytes start from 0\n    # So the initial counter block = data_bytes[:8] + 8 zero bytes\n    initial_counter = list(data_bytes[:8]) + [0] * 8\n\n    # Step 7: Cipher data is the rest after these 8 bytes\n    cipher_data = list(data_bytes[8:])\n\n    # Step 8: Create counter instance\n    counter = AESCounter(initial_counter)\n\n    # Step 9: Decrypt using AES-CTR mode with cipher_key and counter\n    decrypted_data = aes_ctr_decrypt(cipher_data, cipher_key, counter)\n\n    # Step 10: Convert decrypted_data (ints) to bytes and decode utf-8 to string\n    decrypted_bytes = bytes(decrypted_data)\n    try:\n        return decrypted_bytes.decode('utf-8')\n    except UnicodeDecodeError:\n        # If utf-8 decode fails, return as is by decoding with errors replaced\n        return decrypted_bytes.decode('utf-8', errors='replace')"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import aes_ctr_decrypt, aes_encrypt, key_expansion, xor\nfrom youtube_dl.aes import BLOCK_SIZE_BYTES\nfrom youtube_dl.compat import compat_b64decode\n\n\nclass Counter:\n    def __init__(self, high_bytes):\n        \"\"\"\n        Counter instance for AES CTR mode.\n\n        @param {int[]} high_bytes 8 Bytes list representing the high bytes of the counter\n        \"\"\"\n        if len(high_bytes) != 8:\n            raise ValueError(\"High bytes length must be 8\")\n        self.high_bytes = high_bytes[:]\n        self.low_bytes = [0] * 8\n\n    def next_value(self):\n        \"\"\"\n        Return the next 16-Bytes counter block as list of ints:\n        8 bytes high + 8 bytes low. Low part increments on every call.\n\n        @returns {int[]} 16-Byte counter block\n        \"\"\"\n        # Increment low_bytes as 64-bit integer (little endian)\n        carry = 1\n        for i in range(7, -1, -1):\n            new_val = self.low_bytes[i] + carry\n            self.low_bytes[i] = new_val & 0xFF\n            carry = new_val >> 8\n            if carry == 0:\n                break\n\n        return self.high_bytes + self.low_bytes\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Decode base64-encoded data to bytes\n    decoded_bytes = compat_b64decode(data)\n    if len(decoded_bytes) < 8:\n        raise ValueError(\"Decoded data too short to contain counter high bytes\")\n\n    # Extract the first 8 bytes: high bytes of the counter\n    high_bytes = list(decoded_bytes[:8])\n\n    # The rest is the cipher text\n    ciphertext = list(decoded_bytes[8:])\n\n    # Encode password in utf-8 to bytes\n    password_bytes = password.encode('utf-8')\n\n    # Prepare the cipher key:\n    # - Take the first 'key_size_bytes' bytes from password_bytes, pad with zeros if needed\n    key_bytes = list(password_bytes[:key_size_bytes])\n    if len(key_bytes) < key_size_bytes:\n        key_bytes += [0] * (key_size_bytes - len(key_bytes))\n\n    # Take first 16 bytes of password_bytes (or pad with 0s if shorter) as block for encryption\n    block_for_key = list(password_bytes[:16])\n    if len(block_for_key) < 16:\n        block_for_key += [0] * (16 - len(block_for_key))\n\n    # Expand the key\n    expanded_key = key_expansion(key_bytes)\n\n    # Derive the AES key by encrypting block_for_key with expanded_key\n    derived_key = aes_encrypt(block_for_key, expanded_key)\n\n    # Use the derived key for decryption in counter mode\n    counter = Counter(high_bytes)\n    decrypted_ints = aes_ctr_decrypt(ciphertext, derived_key, counter)\n\n    # Convert decrypted ints to bytes and then decode UTF-8 string\n    decrypted_bytes = bytes(decrypted_ints)\n    return decrypted_bytes.decode('utf-8')\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import aes_ctr_decrypt, aes_encrypt, key_expansion\nfrom youtube_dl.compat import compat_b64decode\n\n\nclass AESCounter:\n    def __init__(self, high_bytes):\n        \"\"\"\n        Counter class for AES CTR mode.\n        The counter block is 16 bytes long; the first 8 bytes are zeros,\n        the next 8 bytes are the high_bytes plus a low 8-byte incrementing counter.\n        \"\"\"\n        self.high_bytes = high_bytes  # 8 bytes (int list)\n        self.low = 0\n\n    def next_value(self):\n        # low is 8-byte little-endian integer increment\n        low_bytes = []\n        n = self.low\n        for _ in range(8):\n            low_bytes.append(n & 0xFF)\n            n >>= 8\n        self.low += 1\n\n        # Construct the 16-byte counter block:\n        #  first 8 bytes zero + low_bytes (8 bytes) XORed with high_bytes (8 bytes)\n        # But specification says: \"The first 8 bytes of decoded data are the 8 high bytes of the counter\",\n        # likely the first 8 bytes are high_bytes, then we combine with low counter in last 8 bytes.\n        # According to common CTR usage, counter block = high 8 bytes + low 8 bytes.\n\n        # So counter block = high_bytes (8 bytes) + low_bytes (8 bytes)\n        counter_block = self.high_bytes[:] + low_bytes\n\n        return counter_block\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Decode base64 input data to bytes\n    decoded_data = compat_b64decode(data)\n\n    # Convert decoded_data bytes to list of ints for aes functions\n    data_ints = list(decoded_data)\n\n    # The first 8 bytes of data_ints are the \"high bytes\" of the counter\n    counter_high_bytes = data_ints[:8]\n\n    # The rest is the encrypted content\n    encrypted_data = data_ints[8:]\n\n    # Prepare password key bytes list (utf-8)\n    password_bytes = password.encode('utf-8')\n\n    # Prepare the 'key' with length key_size_bytes with zeros padding if shorter\n    key = list(password_bytes[:key_size_bytes]) + [0] * max(0, key_size_bytes - len(password_bytes))\n\n    # Prepare the first 16 bytes of password padded similarly (for encryption)\n    first_16_password_bytes = list(password_bytes[:16]) + [0] * max(0, 16 - len(password_bytes))\n\n    # Encrypt the first_16_password_bytes with the key to get the cipher key\n    expanded_key = key_expansion(key)\n    cipher_key = aes_encrypt(first_16_password_bytes, expanded_key)  # returns list of 16 ints\n\n    # Create the counter instance with the 8 high bytes\n    counter = AESCounter(counter_high_bytes)\n\n    # Decrypt with AES CTR mode, using the derived cipher key\n    decrypted_ints = aes_ctr_decrypt(encrypted_data, cipher_key, counter)\n\n    # Convert decrypted bytes (list of ints) back to utf-8 string\n    decrypted_bytes = bytes(decrypted_ints)\n    try:\n        decrypted_text = decrypted_bytes.decode('utf-8')\n    except UnicodeDecodeError:\n        # If decoding fails, return raw bytes string fallback\n        decrypted_text = decrypted_bytes.decode('latin1', errors='replace')\n\n    return decrypted_text\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import aes_ctr_decrypt, aes_encrypt, key_expansion\nfrom youtube_dl.compat import compat_b64decode\n\n\nclass Counter:\n    def __init__(self, high_bytes):\n        \"\"\"\n        Initialize the counter object with the first 8 bytes as the high part\n        and the low part initialized to 0.\n        \"\"\"\n        self.high_bytes = high_bytes  # 8 bytes list\n        self.low = 0\n\n    def next_value(self):\n        \"\"\"\n        Returns the next 16-Byte counter block:\n        - first 8 bytes are fixed high_bytes\n        - last 8 bytes are low counter, incremented for each call\n        \n        Represent low as 8-byte big-endian integer.\n        \"\"\"\n        low_bytes = []\n        v = self.low\n        for _ in range(8):\n            low_bytes.append(v & 0xFF)\n            v >>= 8\n        low_bytes.reverse()\n\n        self.low += 1\n        return self.high_bytes + low_bytes\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Step 1: Base64 decode data -> bytes list (int list)\n    decoded_bytes = compat_b64decode(data)\n    data_bytes = list(decoded_bytes)\n\n    # Extract first 8 bytes of data_bytes as high bytes of counter\n    counter_high = data_bytes[:8]\n\n    # The rest of data_bytes after the 8 bytes is the ciphertext\n    ciphertext = data_bytes[8:]\n\n    # Step 2: Prepare password key bytes\n    password_bytes = list(password.encode('utf-8'))\n\n    # Extract key for cipher key derivation: first key_size_bytes of password, padded with 0s if short\n    key_for_key = password_bytes[:key_size_bytes]\n    if len(key_for_key) < key_size_bytes:\n        key_for_key += [0] * (key_size_bytes - len(key_for_key))\n\n    # The data to encrypt to get the actual cipher key is first 16 bytes of password\n    # If password is less than 16 bytes, pad with 0s\n    key_data = password_bytes[:16]\n    if len(key_data) < 16:\n        key_data += [0] * (16 - len(key_data))\n\n    # Step 3: Generate actual cipher key by encrypting key_data with key_for_key\n    expanded_key = key_expansion(key_for_key)\n    cipher_key = aes_encrypt(key_data, expanded_key)\n\n    # Step 4: Use cipher_key in AES CTR mode with counter initialized to counter_high to decrypt ciphertext\n    counter = Counter(counter_high)\n    decrypted_intlist = aes_ctr_decrypt(ciphertext, cipher_key, counter)\n\n    # Step 5: Convert decrypted int list to bytes and decode as UTF-8 string\n    decrypted_bytes = bytes(decrypted_intlist)\n    return decrypted_bytes.decode('utf-8')\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import aes_ctr_decrypt, aes_encrypt, key_expansion\nfrom youtube_dl.compat import compat_b64decode\n\n\nclass Counter:\n    \"\"\"\n    Counter class for AES counter mode encryption/decryption.\n    Initialized with the 8 high bytes. The 8 low bytes of the counter start at 0 and increment by 1 each call.\n    \"\"\"\n\n    def __init__(self, high_bytes):\n        # high_bytes: list of 8 ints\n        self.high = high_bytes[:]  # make a copy\n        self.low = 0\n\n    def next_value(self):\n        # return 16-byte list = high 8 bytes + low 8 bytes (little endian)\n        low_bytes = []\n        temp = self.low\n        for _ in range(8):\n            low_bytes.append(temp & 0xFF)\n            temp >>= 8\n        self.low += 1\n        return self.high + low_bytes\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n\n    # Decode base64 encoded data into bytes\n    decoded_bytes = list(compat_b64decode(data))\n\n    # The first 8 bytes are the high 8 bytes of the counter\n    counter_high_bytes = decoded_bytes[:8]\n\n    # The rest is the ciphertext to decrypt\n    cipher_bytes = decoded_bytes[8:]\n\n    # Prepare the key\n    password_bytes = password.encode('utf-8')\n\n    # The key bytes part: first key_size_bytes from password, padded with zeros if needed\n    key_bytes = list(password_bytes[:key_size_bytes])\n    if len(key_bytes) < key_size_bytes:\n        key_bytes += [0] * (key_size_bytes - len(key_bytes))\n\n    # The first 16 bytes to be encrypted to get the actual cipher key.\n    # If password_bytes less than 16 bytes, pad with zeros\n    first_16_bytes = list(password_bytes[:16])\n    if len(first_16_bytes) < 16:\n        first_16_bytes += [0] * (16 - len(first_16_bytes))\n\n    # Expand key for encrypting first_16_bytes\n    expanded_key = key_expansion(key_bytes)\n\n    # Encrypt first_16_bytes with the prepared key to get cipher_key\n    cipher_key = aes_encrypt(first_16_bytes, expanded_key)\n\n    # Setup counter object with the high 8 bytes\n    counter = Counter(counter_high_bytes)\n\n    # Decrypt cipher_bytes using AES CTR mode with cipher_key and counter\n    decrypted_intlist = aes_ctr_decrypt(cipher_bytes, cipher_key, counter)\n\n    # Convert decrypted int list to bytes and decode to utf-8 string\n    decrypted_bytes = bytes(decrypted_intlist)\n    result = decrypted_bytes.decode('utf-8', errors='replace')\n\n    return result\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom math import ceil\nfrom youtube_dl.aes import aes_ctr_decrypt, aes_encrypt, key_expansion\nfrom youtube_dl.compat import compat_b64decode\n\n\nclass AESCounter:\n    \"\"\"\n    Counter class for AES-CTR mode.\n    Initializes with a 16-byte counter block.\n    The next_value method returns the current counter value and increments the counter by 1 (little-endian).\n    \"\"\"\n    def __init__(self, initial_counter):\n        self.counter = initial_counter[:]\n\n    def next_value(self):\n        # Return current counter value and increment it by 1 (little-endian)\n        current = self.counter[:]\n        # Increment counter by 1 (treat as little-endian integer)\n        for i in range(len(self.counter)):\n            self.counter[i] = (self.counter[i] + 1) & 0xff\n            if self.counter[i] != 0:\n                break\n        return current\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Step 1: Decode base64 data to bytes\n    data_bytes = compat_b64decode(data)\n\n    # data_bytes must be at least 8 bytes for high bytes of counter and some cipher data\n    if len(data_bytes) < 8:\n        return ''\n\n    # Step 2: Password to bytes (utf-8)\n    password_bytes = password.encode('utf-8')\n\n    # Step 3: Prepare the key: first key_size_bytes from password_bytes, zero-padded if needed\n    key = list(password_bytes[:key_size_bytes])\n    if len(key) < key_size_bytes:\n        key += [0] * (key_size_bytes - len(key))\n\n    # Step 4: Prepare first 16 bytes of password (for encryption to get the cipher key)\n    # If password_bytes shorter than 16, pad with zeros\n    password_block = list(password_bytes[:16])\n    if len(password_block) < 16:\n        password_block += [0] * (16 - len(password_block))\n\n    # Step 5: Expand key and encrypt password_block to get cipher key\n    expanded_key = key_expansion(key)\n    cipher_key = aes_encrypt(password_block, expanded_key)\n\n    # Step 6: Extract 8 high bytes of counter from data (first 8 bytes)\n    # Counter is 16 bytes: first 8 bytes are the high bytes given by data_bytes[:8]\n    # The lower 8 bytes start from 0\n    # So the initial counter block = data_bytes[:8] + 8 zero bytes\n    initial_counter = list(data_bytes[:8]) + [0] * 8\n\n    # Step 7: Cipher data is the rest after these 8 bytes\n    cipher_data = list(data_bytes[8:])\n\n    # Step 8: Create counter instance\n    counter = AESCounter(initial_counter)\n\n    # Step 9: Decrypt using AES-CTR mode with cipher_key and counter\n    decrypted_data = aes_ctr_decrypt(cipher_data, cipher_key, counter)\n\n    # Step 10: Convert decrypted_data (ints) to bytes and decode utf-8 to string\n    decrypted_bytes = bytes(decrypted_data)\n    try:\n        return decrypted_bytes.decode('utf-8')\n    except UnicodeDecodeError:\n        # If utf-8 decode fails, return as is by decoding with errors replaced\n        return decrypted_bytes.decode('utf-8', errors='replace')\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n"]}
{"task_id": 152, "project": "test-apps/youtube-dl", "module": "youtube_dl.downloader.f4m", "predictions": ["def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    result = []\n    segments = boot_info.get('segments', [])\n    fragments_groups = boot_info.get('fragments', [])\n\n    # According to abst structure, segments and fragments lists correspond\n    # segments is a list of dicts with a 'segment_run' key with list of tuples\n    # fragments_groups is a list of dicts with a 'fragments' key with list of dicts\n\n    # Iterate over each segment group and corresponding fragment group\n    for segment_group, fragment_group in zip(segments, fragments_groups):\n        segment_runs = segment_group.get('segment_run', [])\n        fragments = fragment_group.get('fragments', [])\n\n        # For each segment run, get the first segment number and number of fragments for that segment\n        for (first_segment, fragments_per_segment) in segment_runs:\n            # We assume fragments are in order and map them accordingly\n            for i in range(fragments_per_segment):\n                idx = first_segment - 1 + i  # segment and fragment indices are 1-based\n                # Defensive check on index range\n                if 0 <= idx < len(fragments):\n                    fragment = fragments[idx]\n                    result.append(((first_segment + i), fragment))\n\n    return result", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    segments = boot_info.get('segments', [])\n    fragments = boot_info.get('fragments', [])\n\n    # The structure of boot_info has 'segments' as a list of segments,\n    # each segment being a dict with a 'segment_run' key,\n    # which is a list of tuples (first_segment, fragments_per_segment).\n    # 'fragments' is a list of fragment runs; each run contains a list of fragment dicts.\n\n    # We assume that segments and fragments runs correspond in order,\n    # and we want to pair each fragment with the originating segment it belongs to.\n\n    # Iterate matching segment runs with fragment runs\n    # For each segment run in segments, get its segment runs list\n    # For each fragment run in fragments, get its fragments list\n    # Then, for each (first_segment, fragments_per_segment) in segment_run,\n    # associate the corresponding fragments in order.\n\n    fragment_index = 0  # index in the flattened fragments list\n\n    for segment in segments:\n        segment_runs = segment.get('segment_run', [])\n        for first_segment, fragments_per_segment in segment_runs:\n            # For each fragment in this segment run\n            for _ in range(fragments_per_segment):\n                # Look for the fragment at fragment_index in all fragments runs concatenated\n                # According to the bootstrap structure, fragments is a list of dicts each having 'fragments' list\n                # Flatten the fragments runs to a list (done below), then index into it\n                # But we do it here lazily collecting fragments first\n\n                # We'll first flatten all fragments runs for easy lookup\n                pass\n\n    # Flatten fragments runs into a single list of fragment dicts\n    all_fragments = []\n    for frag_run in fragments:\n        frag_list = frag_run.get('fragments', [])\n        all_fragments.extend(frag_list)\n\n    fragment_index = 0\n    for segment in segments:\n        segment_runs = segment.get('segment_run', [])\n        for first_segment, fragments_per_segment in segment_runs:\n            for _ in range(fragments_per_segment):\n                if fragment_index >= len(all_fragments):\n                    # Defensive: if fragments are shorter than expected, stop\n                    break\n                fragment = all_fragments[fragment_index]\n                fragments_list.append((segment, fragment))\n                fragment_index += 1\n\n    return fragments_list", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    # We will collect tuples of (segment_dict, fragment_dict)\n    result = []\n\n    # segments is a list of dict, each dict contains a 'segment_run' key\n    # that stores list of tuples (first_segment, fragments_per_segment)\n    # fragments_runs is a list of dict, each dict contains 'fragments',\n    # a list of fragment dicts\n\n    # We iterate over segments and fragments_runs by corresponding indices.\n    # Each segment corresponds to a segments_run (list of tuples (first_segment, fragments_per_segment))\n    # and each fragments_run contains a list of fragments.\n\n    for segment, fragments_run in zip(segments, fragments_runs):\n        segment_runs = segment.get('segment_run', [])\n        fragments = fragments_run.get('fragments', [])\n\n        # We will iterate over each segment run, and for each run,\n        # iterate through the fragments that belong to that run.\n        # The fragments in fragments_run correspond sequentially to these runs.\n\n        # Index in fragments list:\n        frag_idx = 0\n\n        for first_segment, fragments_per_segment in segment_runs:\n            # For each fragment in this segment run, add tuple to result\n            for _ in range(fragments_per_segment):\n                if frag_idx >= len(fragments):\n                    # Defensive: if fragments fewer than expected, break early\n                    break\n                fragment = fragments[frag_idx]\n                # Append tuple of segment_run info + fragment info as requested:\n                # Note: segment_run info is (first_segment, fragments_per_segment),\n                # but we need to return (segment, fragment). Since segment is a dict\n                # and fragment is a dict, provide the segment dict that contains this run.\n                # The \"segment\" in result presumably means the segment dict from boot_info['segments']\n                # The fragment is one fragment dict from fragments list.\n                result.append((segment, fragment))\n                frag_idx += 1\n\n    return result", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_groups = boot_info.get('fragments', [])\n\n    fragments_list = []\n    # segments is a list of dicts with \"segment_run\" key, the segment run is a list of tuples (first_segment, fragments_per_segment)\n    # fragments_groups is a list of dicts with \"fragments\" key, which is a list of fragment dicts with keys 'first', 'ts', 'duration', 'discontinuity_indicator'\n    # We want to return list of (segment, fragment) tuples for each fragment\n\n    # Iterate over corresponding segments and fragments groups by index\n    for segment, fragments_group in zip(segments, fragments_groups):\n        fragment_entries = fragments_group.get('fragments', [])\n        segment_run = segment.get('segment_run', [])\n\n        # For each tuple in segment_run (first_segment, fragments_per_segment) we should map fragments accordingly\n        # The fragments from fragment_entries are arranged to correspond to entries in segment_run sequence with given counts\n\n        idx = 0\n        for first_segment, fragments_per_segment in segment_run:\n            for i in range(fragments_per_segment):\n                if idx >= len(fragment_entries):\n                    break\n                fragment = fragment_entries[idx]\n                # yield the current segment dict and the current fragment dict\n                fragments_list.append((segment, fragment))\n                idx += 1\n\n    return fragments_list", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    # Segments is a list of dicts with 'segment_run' which is a list of tuples:\n    # (first_segment, fragments_per_segment) describing segments with fragment counts.\n    # fragments_runs is a list of dicts with 'fragments' list describing fragments.\n\n    # According to the bootstrap structure:\n    # segments: list of dicts each with \"segment_run\": list of (first_segment, fragments_per_segment)\n    # fragments: list of dicts each with \"fragments\": list of fragment dicts\n\n    # We need to pair each segment number with each fragment.\n    # The segments and fragments are structured often in sequence.\n\n    # It appears segments and fragments_runs correspond index-wise,\n    # i.e. segments[i] relates to fragments_runs[i]\n    # Each segment defines a series of segment_run tuples (first segments and counts),\n    # each fragments_run contains fragments with info about those fragments.\n\n    # Build a combined list of (segment number, fragment) for all fragments.\n\n    fragment_index = 0\n    for seg_idx, (segment_info, fragment_run) in enumerate(zip(segments, fragments_runs)):\n        segment_run = segment_info.get('segment_run', [])\n        fragments = fragment_run.get('fragments', [])\n\n        # Each segment_run entry: (first_segment, fragments_per_segment)\n        # The fragments correspond to these segments sequentially.\n\n        frag_cursor = 0\n        for first_segment, fragments_per_segment in segment_run:\n            # For each segment in this run, from first_segment up to count\n            for seg_number in range(first_segment, first_segment + fragments_per_segment):\n                if frag_cursor >= len(fragments):\n                    # Defensive: no more fragments to assign\n                    break\n                fragments_list.append((seg_number, fragments[frag_cursor]))\n                frag_cursor += 1\n\n    return fragments_list"], "test": ["from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    result = []\n    segments = boot_info.get('segments', [])\n    fragments_groups = boot_info.get('fragments', [])\n\n    # According to abst structure, segments and fragments lists correspond\n    # segments is a list of dicts with a 'segment_run' key with list of tuples\n    # fragments_groups is a list of dicts with a 'fragments' key with list of dicts\n\n    # Iterate over each segment group and corresponding fragment group\n    for segment_group, fragment_group in zip(segments, fragments_groups):\n        segment_runs = segment_group.get('segment_run', [])\n        fragments = fragment_group.get('fragments', [])\n\n        # For each segment run, get the first segment number and number of fragments for that segment\n        for (first_segment, fragments_per_segment) in segment_runs:\n            # We assume fragments are in order and map them accordingly\n            for i in range(fragments_per_segment):\n                idx = first_segment - 1 + i  # segment and fragment indices are 1-based\n                # Defensive check on index range\n                if 0 <= idx < len(fragments):\n                    fragment = fragments[idx]\n                    result.append(((first_segment + i), fragment))\n\n    return result\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    segments = boot_info.get('segments', [])\n    fragments = boot_info.get('fragments', [])\n\n    # The structure of boot_info has 'segments' as a list of segments,\n    # each segment being a dict with a 'segment_run' key,\n    # which is a list of tuples (first_segment, fragments_per_segment).\n    # 'fragments' is a list of fragment runs; each run contains a list of fragment dicts.\n\n    # We assume that segments and fragments runs correspond in order,\n    # and we want to pair each fragment with the originating segment it belongs to.\n\n    # Iterate matching segment runs with fragment runs\n    # For each segment run in segments, get its segment runs list\n    # For each fragment run in fragments, get its fragments list\n    # Then, for each (first_segment, fragments_per_segment) in segment_run,\n    # associate the corresponding fragments in order.\n\n    fragment_index = 0  # index in the flattened fragments list\n\n    for segment in segments:\n        segment_runs = segment.get('segment_run', [])\n        for first_segment, fragments_per_segment in segment_runs:\n            # For each fragment in this segment run\n            for _ in range(fragments_per_segment):\n                # Look for the fragment at fragment_index in all fragments runs concatenated\n                # According to the bootstrap structure, fragments is a list of dicts each having 'fragments' list\n                # Flatten the fragments runs to a list (done below), then index into it\n                # But we do it here lazily collecting fragments first\n\n                # We'll first flatten all fragments runs for easy lookup\n                pass\n\n    # Flatten fragments runs into a single list of fragment dicts\n    all_fragments = []\n    for frag_run in fragments:\n        frag_list = frag_run.get('fragments', [])\n        all_fragments.extend(frag_list)\n\n    fragment_index = 0\n    for segment in segments:\n        segment_runs = segment.get('segment_run', [])\n        for first_segment, fragments_per_segment in segment_runs:\n            for _ in range(fragments_per_segment):\n                if fragment_index >= len(all_fragments):\n                    # Defensive: if fragments are shorter than expected, stop\n                    break\n                fragment = all_fragments[fragment_index]\n                fragments_list.append((segment, fragment))\n                fragment_index += 1\n\n    return fragments_list\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    # We will collect tuples of (segment_dict, fragment_dict)\n    result = []\n\n    # segments is a list of dict, each dict contains a 'segment_run' key\n    # that stores list of tuples (first_segment, fragments_per_segment)\n    # fragments_runs is a list of dict, each dict contains 'fragments',\n    # a list of fragment dicts\n\n    # We iterate over segments and fragments_runs by corresponding indices.\n    # Each segment corresponds to a segments_run (list of tuples (first_segment, fragments_per_segment))\n    # and each fragments_run contains a list of fragments.\n\n    for segment, fragments_run in zip(segments, fragments_runs):\n        segment_runs = segment.get('segment_run', [])\n        fragments = fragments_run.get('fragments', [])\n\n        # We will iterate over each segment run, and for each run,\n        # iterate through the fragments that belong to that run.\n        # The fragments in fragments_run correspond sequentially to these runs.\n\n        # Index in fragments list:\n        frag_idx = 0\n\n        for first_segment, fragments_per_segment in segment_runs:\n            # For each fragment in this segment run, add tuple to result\n            for _ in range(fragments_per_segment):\n                if frag_idx >= len(fragments):\n                    # Defensive: if fragments fewer than expected, break early\n                    break\n                fragment = fragments[frag_idx]\n                # Append tuple of segment_run info + fragment info as requested:\n                # Note: segment_run info is (first_segment, fragments_per_segment),\n                # but we need to return (segment, fragment). Since segment is a dict\n                # and fragment is a dict, provide the segment dict that contains this run.\n                # The \"segment\" in result presumably means the segment dict from boot_info['segments']\n                # The fragment is one fragment dict from fragments list.\n                result.append((segment, fragment))\n                frag_idx += 1\n\n    return result\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_groups = boot_info.get('fragments', [])\n\n    fragments_list = []\n    # segments is a list of dicts with \"segment_run\" key, the segment run is a list of tuples (first_segment, fragments_per_segment)\n    # fragments_groups is a list of dicts with \"fragments\" key, which is a list of fragment dicts with keys 'first', 'ts', 'duration', 'discontinuity_indicator'\n    # We want to return list of (segment, fragment) tuples for each fragment\n\n    # Iterate over corresponding segments and fragments groups by index\n    for segment, fragments_group in zip(segments, fragments_groups):\n        fragment_entries = fragments_group.get('fragments', [])\n        segment_run = segment.get('segment_run', [])\n\n        # For each tuple in segment_run (first_segment, fragments_per_segment) we should map fragments accordingly\n        # The fragments from fragment_entries are arranged to correspond to entries in segment_run sequence with given counts\n\n        idx = 0\n        for first_segment, fragments_per_segment in segment_run:\n            for i in range(fragments_per_segment):\n                if idx >= len(fragment_entries):\n                    break\n                fragment = fragment_entries[idx]\n                # yield the current segment dict and the current fragment dict\n                fragments_list.append((segment, fragment))\n                idx += 1\n\n    return fragments_list\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    # Segments is a list of dicts with 'segment_run' which is a list of tuples:\n    # (first_segment, fragments_per_segment) describing segments with fragment counts.\n    # fragments_runs is a list of dicts with 'fragments' list describing fragments.\n\n    # According to the bootstrap structure:\n    # segments: list of dicts each with \"segment_run\": list of (first_segment, fragments_per_segment)\n    # fragments: list of dicts each with \"fragments\": list of fragment dicts\n\n    # We need to pair each segment number with each fragment.\n    # The segments and fragments are structured often in sequence.\n\n    # It appears segments and fragments_runs correspond index-wise,\n    # i.e. segments[i] relates to fragments_runs[i]\n    # Each segment defines a series of segment_run tuples (first segments and counts),\n    # each fragments_run contains fragments with info about those fragments.\n\n    # Build a combined list of (segment number, fragment) for all fragments.\n\n    fragment_index = 0\n    for seg_idx, (segment_info, fragment_run) in enumerate(zip(segments, fragments_runs)):\n        segment_run = segment_info.get('segment_run', [])\n        fragments = fragment_run.get('fragments', [])\n\n        # Each segment_run entry: (first_segment, fragments_per_segment)\n        # The fragments correspond to these segments sequentially.\n\n        frag_cursor = 0\n        for first_segment, fragments_per_segment in segment_run:\n            # For each segment in this run, from first_segment up to count\n            for seg_number in range(first_segment, first_segment + fragments_per_segment):\n                if frag_cursor >= len(fragments):\n                    # Defensive: no more fragments to assign\n                    break\n                fragments_list.append((seg_number, fragments[frag_cursor]))\n                frag_cursor += 1\n\n    return fragments_list\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n"]}
